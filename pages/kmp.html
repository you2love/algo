<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMP算法 - 算法学习指南</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../lib/prism/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../lib/prism/prism-line-numbers.min.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <h1 class="logo"></h1>
            <ul class="nav-links">
                <li><a href="../index.html">首页</a></li>
                <li><a href="../index.html#algorithms">算法分类</a></li>
                <li><a href="../index.html#practice">在线练习</a></li>
            </ul>
        </div>
    </nav>

    <section class="algorithm-detail">
        <div class="container">
            <a href="../index.html#algorithms" class="back-link">← 返回算法分类</a>
            <h2>KMP字符串匹配算法</h2>
            
            <div class="algorithm-content">
                <h3>什么是KMP算法？</h3>
                <p>KMP算法（Knuth-Morris-Pratt算法）是一种高效的字符串匹配算法，由Donald Knuth、James Morris和Vaughan Pratt于1977年共同提出。它用于在主文本串中查找模式串的出现位置，时间复杂度为O(n+m)，其中n是文本长度，m是模式长度。</p>
            </div>

            <div class="complexity">
                <div class="complexity-item">
                    <h4>时间复杂度</h4>
                    <p>O(n + m)</p>
                </div>
                <div class="complexity-item">
                    <h4>空间复杂度</h4>
                    <p>O(m)</p>
                </div>
                <div class="complexity-item">
                    <h4>最优情况</h4>
                    <p>O(n)</p>
                </div>
            </div>

            <h3>为什么需要KMP？</h3>
            <div class="algorithm-content">
                <p>考虑一个简单的例子：在文本"ABABABC"中查找模式"ABABC"。</p>
                <p><strong>暴力匹配的缺点：</strong></p>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li>当匹配失败时，模式串总是回退到起始位置</li>
                    <li>已匹配的信息被完全丢弃，无法利用</li>
                    <li>最坏情况下时间复杂度为O(n*m)</li>
                </ul>
                <p style="margin-top: 15px;"><strong>KMP的核心思想：</strong></p>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li>当匹配失败时，利用已匹配的信息跳过不必要的比较</li>
                    <li>通过"部分匹配表"（PMT/Next数组）指导模式串的移动</li>
                    <li>文本串的指针永不后退</li>
                </ul>
            </div>

            <h3>前缀函数（Next数组）原理</h3>
            <div class="algorithm-content">
                <p><strong>定义：</strong>next[i]表示模式串P[0...i]的最长相等前后缀的长度。</p>
                <p style="margin-top: 15px;"><strong>为什么需要前后缀？</strong></p>
                <p>考虑模式串"ABAB"，当匹配到第4个字符失败时：</p>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li>模式串前缀"ABA"等于已匹配的后缀"ABA"</li>
                    <li>我们可以直接将模式串向右滑动，让前缀对齐后缀</li>
                    <li>避免了从头开始匹配</li>
                </ul>
                <p style="margin-top: 15px;"><strong>计算next数组的递推公式：</strong></p>
                <div style="background: #2d2d2d; padding: 15px; border-radius: 8px; margin-top: 10px; font-family: 'Consolas', monospace; color: #f8f8f2;">
                    <p>if P[k] == P[j]: next[j] = k + 1</p>
                    <p>else: k = next[k-1], 继续比较</p>
                    <p>如果k为0且不匹配: next[j] = 0</p>
                </div>
            </div>

            <h3>手动计算next数组示例</h3>
            <div class="algorithm-content">
                <p>以模式串"ABABC"为例：</p>
                <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                    <tr style="background: #3498db; color: white;">
                        <th style="padding: 12px; text-align: center;">i</th>
                        <th style="padding: 12px; text-align: center;">字符</th>
                        <th style="padding: 12px; text-align: center;">最长相等前后缀</th>
                        <th style="padding: 12px; text-align: center;">next[i]</th>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px; text-align: center;">0</td>
                        <td style="padding: 12px; text-align: center;">A</td>
                        <td style="padding: 12px; text-align: center;">无</td>
                        <td style="padding: 12px; text-align: center;">0</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; text-align: center;">1</td>
                        <td style="padding: 12px; text-align: center;">B</td>
                        <td style="padding: 12px; text-align: center;">无</td>
                        <td style="padding: 12px; text-align: center;">0</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px; text-align: center;">2</td>
                        <td style="padding: 12px; text-align: center;">A</td>
                        <td style="padding: 12px; text-align: center;">"A"</td>
                        <td style="padding: 12px; text-align: center;">1</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; text-align: center;">3</td>
                        <td style="padding: 12px; text-align: center;">B</td>
                        <td style="padding: 12px; text-align: center;">"AB"</td>
                        <td style="padding: 12px; text-align: center;">2</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px; text-align: center;">4</td>
                        <td style="padding: 12px; text-align: center;">C</td>
                        <td style="padding: 12px; text-align: center;">无</td>
                        <td style="padding: 12px; text-align: center;">0</td>
                    </tr>
                </table>
                <p style="margin-top: 15px;">最终next数组：[0, 0, 1, 2, 0]</p>
            </div>

            <h3>KMP匹配过程示例</h3>
            <div class="algorithm-content">
                <p>在文本"ABABABABC"中查找模式"ABABC"：</p>
                <div style="background: #2d2d2d; padding: 15px; border-radius: 8px; margin-top: 10px; font-family: 'Consolas', monospace; color: #f8f8f2; white-space: pre; overflow-x: auto;">
文本: A B A B A B A B C
模式: A B A B C
           ↓ 匹配前4个字符

文本: A B A B A B A B C
模式:     A B A B C
           ↑ 在第5个字符(C)匹配失败
           → 查看next[4]=0，跳转到模式开头

文本: A B A B A B A B C
模式:         A B A B C
           ↓ 继续匹配
           → 匹配成功！位置4-8
                </div>
            </div>

            <h3>算法实现</h3>
            <div class="code-tabs">
                <div class="code-tab-header">
                    <button class="code-tab-btn active" data-tab="kmp-js">JavaScript</button>
                    <button class="code-tab-btn" data-tab="kmp-python">Python</button>
                    <button class="code-tab-btn" data-tab="kmp-go">Go</button>
                </div>
                <div id="kmp-js" class="code-tab-content active">
                    <div class="code-block line-numbers"><pre><code class="language-javascript">
function computeNext(pattern) {
    const next = new Array(pattern.length).fill(0);
    let j = 0;
    
    for (let i = 1; i < pattern.length; i++) {
        while (j > 0 && pattern[i] !== pattern[j]) {
            j = next[j - 1];
        }
        if (pattern[i] === pattern[j]) {
            j++;
        }
        next[i] = j;
    }
    
    return next;
}

function kmpSearch(text, pattern) {
    if (pattern.length === 0) return 0;
    
    const next = computeNext(pattern);
    let j = 0;
    
    for (let i = 0; i < text.length; i++) {
        while (j > 0 && text[i] !== pattern[j]) {
            j = next[j - 1];
        }
        if (text[i] === pattern[j]) {
            j++;
        }
        if (j === pattern.length) {
            return i - pattern.length + 1; // 找到匹配
        }
    }
    
    return -1; // 未找到
}

// 测试
const text = "ABABABABC";
const pattern = "ABABC";
console.log(kmpSearch(text, pattern)); // 4

const text2 = "ABCABCDABABCDABCDABDE";
const pattern2 = "ABCDABD";
console.log(kmpSearch(text2, pattern2)); // 15
                    </code></pre></div>
                </div>
                <div id="kmp-python" class="code-tab-content">
                    <div class="code-block line-numbers"><pre><code class="language-python">
def compute_next(pattern):
    next_arr = [0] * len(pattern)
    j = 0
    
    for i in range(1, len(pattern)):
        while j > 0 and pattern[i] != pattern[j]:
            j = next_arr[j - 1]
        if pattern[i] == pattern[j]:
            j += 1
        next_arr[i] = j
    
    return next_arr

def kmp_search(text, pattern):
    if len(pattern) == 0:
        return 0
    
    next_arr = compute_next(pattern)
    j = 0
    
    for i in range(len(text)):
        while j > 0 and text[i] != pattern[j]:
            j = next_arr[j - 1]
        if text[i] == pattern[j]:
            j += 1
        if j == len(pattern):
            return i - len(pattern) + 1  # 找到匹配
    
    return -1  # 未找到

# 测试
text = "ABABABABC"
pattern = "ABABC"
print(kmp_search(text, pattern))  # 4

text2 = "ABCABCDABABCDABCDABDE"
pattern2 = "ABCDABD"
print(kmp_search(text2, pattern2))  # 15
                    </code></pre></div>
                </div>
                <div id="kmp-go" class="code-tab-content">
                    <div class="code-block line-numbers"><pre><code class="language-go">
package main

import "fmt"

func computeNext(pattern string) []int {
    next := make([]int, len(pattern))
    j := 0
    
    for i := 1; i < len(pattern); i++ {
        for j > 0 && pattern[i] != pattern[j] {
            j = next[j-1]
        }
        if pattern[i] == pattern[j] {
            j++
        }
        next[i] = j
    }
    
    return next
}

func kmpSearch(text, pattern string) int {
    if len(pattern) == 0 {
        return 0
    }
    
    next := computeNext(pattern)
    j := 0
    
    for i := 0; i < len(text); i++ {
        for j > 0 && text[i] != pattern[j] {
            j = next[j-1]
        }
        if text[i] == pattern[j] {
            j++
        }
        if j == len(pattern) {
            return i - len(pattern) + 1
        }
    }
    
    return -1
}

func main() {
    text := "ABABABABC"
    pattern := "ABABC"
    fmt.Println(kmpSearch(text, pattern)) // 4
    
    text2 := "ABCABCDABABCDABCDABDE"
    pattern2 := "ABCDABD"
    fmt.Println(kmpSearch(text2, pattern2)) // 15
}
                    </code></pre></div>
                </div>
            </div>

            <h3>优化版Next数组</h3>
            <div class="algorithm-content">
                <p>上述next数组可以进一步优化，避免不必要的比较：</p>
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="optimized-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="optimized-python">Python</button>
                    </div>
                    <div id="optimized-js" class="code-tab-content active">
                        <div class="code-block line-numbers"><pre><code class="language-javascript">
function computeNextOptimized(pattern) {
    const next = new Array(pattern.length).fill(-1);
    let j = 0, k = -1;
    
    while (j < pattern.length - 1) {
        if (k === -1 || pattern[j] === pattern[k]) {
            j++;
            k++;
            // 优化：如果下一个字符也相等，跳过
            if (pattern[j] !== pattern[k]) {
                next[j] = k;
            } else {
                next[j] = next[k];
            }
        } else {
            k = next[k];
        }
    }
    
    return next;
}
                        </code></pre></div>
                    </div>
                    <div id="optimized-python" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-python">
def compute_next_optimized(pattern):
    next_arr = [-1] * len(pattern)
    j, k = 0, -1
    
    while j < len(pattern) - 1:
        if k == -1 or pattern[j] == pattern[k]:
            j += 1
            k += 1
            if j < len(pattern) and pattern[j] != pattern[k]:
                next_arr[j] = k
            else:
                next_arr[j] = next_arr[k]
        else:
            k = next_arr[k]
    
    return next_arr
                        </code></pre></div>
                    </div>
                </div>
            </div>

            <h3>KMP算法的应用场景</h3>
            <div class="algorithm-content">
                <ul>
                    <li>文本编辑器中的查找功能</li>
                    <li>生物信息学中的DNA序列匹配</li>
                    <li>字符串查找和替换操作</li>
                    <li>模式匹配相关问题的预处理步骤</li>
                    <li>编译器中的词法分析</li>
                </ul>
            </div>

            <h3>学习建议</h3>
            <div class="algorithm-content">
                <ul>
                    <li>先理解暴力匹配的局限性</li>
                    <li>重点理解next数组的含义和计算方法</li>
                    <li>手动模拟KMP匹配过程，加深理解</li>
                    <li>对比暴力匹配和KMP的时间复杂度</li>
                    <li>尝试实现优化版的next数组</li>
                </ul>
            </div>
        </div>
    </section>

    <script src="../js/main.js"></script>
    <script src="../lib/prism/prism.min.js"></script>
    <script src="../lib/prism/prism-python.min.js"></script>
    <script src="../lib/prism/prism-go.min.js"></script>
    <script src="../lib/prism/prism-line-numbers.min.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>下推自动机 - 算法学习指南</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../lib/prism/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../lib/prism/prism-line-numbers.min.css">
    <style>
        .pda-diagram {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 40px;
            margin: 30px 0;
            padding: 30px;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            border-radius: 15px;
            flex-wrap: wrap;
        }
        
        .pda-component {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-align: center;
            min-width: 150px;
        }
        
        .pda-component h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .control-unit {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            margin: 0 auto 10px;
        }
        
        .stack-visual {
            width: 80px;
            height: 120px;
            background: linear-gradient(180deg, #f093fb 0%, #f5576c 100%);
            border-radius: 5px;
            display: flex;
            flex-direction: column-reverse;
            justify-content: flex-start;
            align-items: center;
            padding: 5px;
            margin: 0 auto;
        }
        
        .stack-symbol {
            width: 40px;
            height: 20px;
            background: white;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin: 2px 0;
            color: #2c3e50;
        }
        
        .tape-visual {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 0;
            margin: 20px 0;
            overflow-x: auto;
            padding: 10px;
        }
        
        .tape-cell {
            min-width: 40px;
            height: 40px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .tape-cell.current {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .transition-visual {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: #f0f4f8;
            border-radius: 10px;
        }
        
        .transition-step {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .transition-step .arrow {
            font-size: 24px;
            color: #3498db;
        }
        
        .highlight-text {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .concept-box {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .math-formula {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
            border-radius: 0 8px 8px 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .comparison-table th,
        .comparison-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .comparison-table th {
            background: #3498db;
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .pda-transition-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .pda-transition-table th,
        .pda-transition-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
            font-family: monospace;
        }
        
        .pda-transition-table th {
            background: #9b59b6;
            color: white;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <h1 class="logo">AlgoLearn</h1>
            <ul class="nav-links">
                <li><a href="../index.html">首页</a></li>
                <li><a href="../index.html#algorithms">算法分类</a></li>
            </ul>
        </div>
    </nav>

    <section class="algorithm-detail">
        <div class="container">
            <a href="../index.html#algorithms" class="back-link">← 返回算法分类</a>
            <h2>下推自动机 (PDA)</h2>
            
            <div class="algorithm-content">
                <h3>什么是下推自动机？</h3>
                <p>
                    <strong>下推自动机 (Pushdown Automaton, PDA)</strong> 是一种扩展了栈式存储的有限自动机。
                    通过栈的"后进先出"特性，PDA 可以识别正则语言无法处理的上下文无关语言。
                </p>
                <p>
                    下推自动机的核心思想是：<span class="highlight-text">
                    利用栈来存储和匹配嵌套结构，从而识别如 aⁿbⁿ、平衡括号等语言</span>。
                </p>
            </div>

            <div class="complexity">
                <div class="complexity-item">
                    <h4>空间复杂度</h4>
                    <p>O(n) - 栈空间</p>
                </div>
                <div class="complexity-item">
                    <h4>时间复杂度</h4>
                    <p>O(n) - 字符串长度</p>
                </div>
                <div class="complexity-item">
                    <h4>识别能力</h4>
                    <p>上下文无关语言</p>
                </div>
            </div>

            <h2>形式化定义</h2>
            <div class="algorithm-content">
                <p>下推自动机是一个七元组：</p>
                <div class="math-formula">
                    <p><strong>M = (Q, Σ, Γ, δ, q₀, Z₀, F)</strong></p>
                    <br>
                    <p>其中：</p>
                    <p>• <strong>Q</strong> = 有限状态集合</p>
                    <p>• <strong>Σ</strong> = 输入字母表</p>
                    <p>• <strong>Γ</strong> = 栈符号字母表</p>
                    <p>• <strong>δ</strong> = 转移函数</p>
                    <p>• <strong>q₀</strong> = 初始状态</p>
                    <p>• <strong>Z₀</strong> = 栈初始符号 (栈底标记)</p>
                    <p>• <strong>F</strong> = 接受状态集合</p>
                </div>
            </div>

            <h2>PDA 结构</h2>
            <div class="pda-diagram">
                <div class="pda-component">
                    <h4>控制单元</h4>
                    <div class="control-unit">状态</div>
                    <p>有限状态控制器</p>
                </div>
                <div class="pda-component">
                    <h4>输入带</h4>
                    <div class="tape-visual">
                        <div class="tape-cell">a</div>
                        <div class="tape-cell">a</div>
                        <div class="tape-cell current">a</div>
                        <div class="tape-cell">b</div>
                        <div class="tape-cell">b</div>
                        <div class="tape-cell">b</div>
                    </div>
                    <p>只读输入</p>
                </div>
                <div class="pda-component">
                    <h4>栈</h4>
                    <div class="stack-visual">
                        <div class="stack-symbol">$</div>
                        <div class="stack-symbol">a</div>
                        <div class="stack-symbol">a</div>
                        <div class="stack-symbol">a</div>
                    </div>
                    <p>LIFO 存储</p>
                </div>
            </div>

            <h2>转移函数</h2>
            <div class="algorithm-content">
                <p>PDA 的转移函数形式：</p>
                <div class="math-formula">
                    <p><strong>δ(q, a, X) = {(p, Y₁Y₂...Yₖ)}</strong></p>
                    <br>
                    <p>含义：</p>
                    <p>• 在状态 q</p>
                    <p>• 读取输入 a (或 ε)</p>
                    <p>• 栈顶为 X</p>
                    <p>• 转移到状态 p</p>
                    <p>• 用 Y₁Y₂...Yₖ 替换栈顶的 X</p>
                </div>
                
                <p style="color: #e74c3c; margin-top: 15px;">
                    ⚠️ 特殊操作：<br>
                    • 压栈：添加符号到栈顶<br>
                    • 弹栈：移除栈顶符号<br>
                    • 保持：栈顶不变
                </p>
            </div>

            <h2>示例：识别 aⁿbⁿ</h2>
            <div class="algorithm-content">
                <p>设计 PDA 识别语言 {aⁿbⁿ | n ≥ 1}</p>
                
                <h3>形式化定义</h3>
                <div class="math-formula">
                    <p>M = ({q₀, q₁, q₂}, {a, b}, {a, Z₀}, δ, q₀, Z₀, {q₂})</p>
                </div>

                <h3>状态转移表</h3>
                <table class="pda-transition-table">
                    <tr>
                        <th>状态</th>
                        <th>输入</th>
                        <th>栈顶</th>
                        <th>转移 (新状态, 栈操作)</th>
                    </tr>
                    <tr>
                        <td>q₀</td>
                        <td>a</td>
                        <td>Z₀</td>
                        <td>(q₀, aZ₀) - 压入 a</td>
                    </tr>
                    <tr>
                        <td>q₀</td>
                        <td>a</td>
                        <td>a</td>
                        <td>(q₀, aa) - 压入 a</td>
                    </tr>
                    <tr>
                        <td>q₀</td>
                        <td>b</td>
                        <td>a</td>
                        <td>(q₁, ε) - 弹出 a</td>
                    </tr>
                    <tr>
                        <td>q₁</td>
                        <td>b</td>
                        <td>a</td>
                        <td>(q₁, ε) - 弹出 a</td>
                    </tr>
                    <tr>
                        <td>q₁</td>
                        <td>ε</td>
                        <td>Z₀</td>
                        <td>(q₂, Z₀) - 接受</td>
                    </tr>
                </table>

                <h3>执行示例：aaabbb</h3>
                <div class="transition-visual">
                    <div class="transition-step">
                        <div class="step-num">1</div>
                        <p>q₀, aaabbb, Z₀</p>
                    </div>
                    <div class="transition-step">
                        <div class="arrow">→</div>
                    </div>
                    <div class="transition-step">
                        <div class="step-num">2</div>
                        <p>q₀, aabbb, aZ₀</p>
                    </div>
                    <div class="transition-step">
                        <div class="arrow">→</div>
                    </div>
                    <div class="transition-step">
                        <div class="step-num">3</div>
                        <p>q₀, abbb, aaZ₀</p>
                    </div>
                    <div class="transition-step">
                        <div class="arrow">→</div>
                    </div>
                    <div class="transition-step">
                        <div class="step-num">4</div>
                        <p>q₀, bbb, aaaZ₀</p>
                    </div>
                    <div class="transition-step">
                        <div class="arrow">→</div>
                    </div>
                    <div class="transition-step">
                        <div class="step-num">5</div>
                        <p>q₁, bb, aaZ₀</p>
                    </div>
                    <div class="transition-step">
                        <div class="arrow">→</div>
                    </div>
                    <div class="transition-step">
                        <div class="step-num">6</div>
                        <p>q₁, b, aZ₀</p>
                    </div>
                    <div class="transition-step">
                        <div class="arrow">→</div>
                    </div>
                    <div class="transition-step">
                        <div class="step-num">7</div>
                        <p>q₁, ε, Z₀</p>
                    </div>
                </div>
            </div>

            <h2>示例：识别平衡括号</h2>
            <div class="algorithm-content">
                <p>设计 PDA 识别语言：平衡的圆括号串</p>
                
                <h3>形式化定义</h3>
                <div class="math-formula">
                    <p>M = ({q₀, q₁}, {(, )}, {(, Z₀}, δ, q₀, Z₀, {q₀})</p>
                </div>

                <h3>状态转移规则</h3>
                <table class="pda-transition-table">
                    <tr>
                        <th>状态</th>
                        <th>输入</th>
                        <th>栈顶</th>
                        <th>转移</th>
                    </tr>
                    <tr>
                        <td>q₀</td>
                        <td>(</td>
                        <td>Z₀</td>
                        <td>(q₀, (Z₀)</td>
                    </tr>
                    <tr>
                        <td>q₀</td>
                        <td>(</td>
                        <td>(</td>
                        <td>(q₀, ((</td>
                    </tr>
                    <tr>
                        <td>q₀</td>
                        <td>)</td>
                        <td>(</td>
                        <td>(q₀, ε)</td>
                    </tr>
                    <tr>
                        <td>q₀</td>
                        <td>ε</td>
                        <td>Z₀</td>
                        <td>(q₀, Z₀)</td>
                    </tr>
                </table>
            </div>

            <h2>接受方式</h2>
            <div class="algorithm-content">
                <p>PDA 有两种接受方式：</p>
                
                <div class="concept-box">
                    <h4>1. 空栈接受</h4>
                    <p>输入完成后栈为空则接受</p>
                    <p>适用场景：与上下文无关文法的直接对应</p>
                </div>
                
                <div class="concept-box">
                    <h4>2. 最终状态接受</h4>
                    <p>输入完成后处于接受状态则接受</p>
                    <p>适用场景：与 NFA/DFA 的接受方式一致</p>
                </div>
                
                <div class="math-formula">
                    <p><strong>定理</strong>：两种接受方式等价（可以通过构造相互转换）</p>
                </div>
            </div>

            <h2>完整实现</h2>
            <div class="algorithm-content">
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="pda-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="pda-python">Python</button>
                        <button class="code-tab-btn" data-tab="pda-go">Go</button>
                    </div>
                    <div id="pda-js" class="code-tab-content active">
                        <div class="code-block line-numbers">
                            <pre><code class="language-javascript">
class PDA {
    constructor() {
        this.states = new Set();
        this.inputAlphabet = new Set();
        this.stackAlphabet = new Set();
        this.transitions = new Map();
        this.startState = null;
        this.startStackSymbol = null;
        this.acceptStates = new Set();
    }
    
    // 格式: δ(q, a, X) = {(p, γ)}
    // 存储为: key = "q:a:X", value = Set of "p:γ"
    addTransition(state, input, stackTop, nextState, stackPush) {
        const key = `${state}:${input}:${stackTop}`;
        
        if (!this.transitions.has(key)) {
            this.transitions.set(key, new Set());
        }
        
        this.transitions.get(key).add(`${nextState}:${stackPush}`);
        this.states.add(state);
        this.states.add(nextState);
        this.inputAlphabet.add(input);
        this.stackAlphabet.add(stackTop);
        this.stackAlphabet.add(...stackPush.split(''));
    }
    
    setStartState(state) {
        this.startState = state;
    }
    
    setStartStackSymbol(symbol) {
        this.startStackSymbol = symbol;
    }
    
    addAcceptState(state) {
        this.acceptStates.add(state);
    }
    
    // 使用最终状态接受
    acceptsByState(input) {
        // 配置: (当前状态, 剩余输入, 栈)
        const config = {
            state: this.startState,
            input: input,
            stack: [this.startStackSymbol]
        };
        
        return this.acceptsFinalState(config);
    }
    
    // 使用空栈接受
    acceptsByEmptyStack(input) {
        const config = {
            state: this.startState,
            input: input,
            stack: [this.startStackSymbol]
        };
        
        return this.acceptsEmptyStack(config);
    }
    
    acceptsFinalState(config) {
        const { state, input, stack } = config;
        
        // 基础情况：输入为空且在接受状态
        if (input.length === 0) {
            return this.acceptStates.has(state);
        }
        
        const currentInput = input[0];
        const remainingInput = input.slice(1);
        const stackTop = stack[stack.length - 1];
        
        // 尝试 ε 转移
        const epsilonKey = `${state}:ε:${stackTop}`;
        if (this.transitions.has(epsilonKey)) {
            for (const trans of this.transitions.get(epsilonKey)) {
                const [nextState, stackPush] = trans.split(':');
                const newStack = [...stack.slice(0, -1), ...stackPush.split('')];
                
                if (this.acceptsFinalState({
                    state: nextState,
                    input: input,
                    stack: newStack
                })) {
                    return true;
                }
            }
        }
        
        // 尝试普通转移
        const key = `${state}:${currentInput}:${stackTop}`;
        if (this.transitions.has(key)) {
            for (const trans of this.transitions.get(key)) {
                const [nextState, stackPush] = trans.split(':');
                const newStack = [...stack.slice(0, -1), ...stackPush.split('')];
                
                if (this.acceptsFinalState({
                    state: nextState,
                    input: remainingInput,
                    stack: newStack
                })) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    acceptsEmptyStack(config) {
        const { state, input, stack } = config;
        
        // 基础情况：栈为空（只剩初始符号）且输入为空
        if (input.length === 0 && stack.length === 1 && stack[0] === this.startStackSymbol) {
            return true;
        }
        
        if (stack.length === 0) {
            return false;
        }
        
        const currentInput = input[0] || 'ε';
        const remainingInput = input.slice(1);
        const stackTop = stack[stack.length - 1];
        
        // 尝试 ε 转移
        const epsilonKey = `${state}:ε:${stackTop}`;
        if (this.transitions.has(epsilonKey)) {
            for (const trans of this.transitions.get(epsilonKey)) {
                const [nextState, stackPush] = trans.split(':');
                const newStack = stackPush === 'ε' 
                    ? stack.slice(0, -1)
                    : [...stack.slice(0, -1), ...stackPush.split('')];
                
                if (this.acceptsEmptyStack({
                    state: nextState,
                    input: input,
                    stack: newStack
                })) {
                    return true;
                }
            }
        }
        
        // 尝试普通转移
        if (input.length > 0) {
            const key = `${state}:${currentInput}:${stackTop}`;
            if (this.transitions.has(key)) {
                for (const trans of this.transitions.get(key)) {
                    const [nextState, stackPush] = trans.split(':');
                    const newStack = stackPush === 'ε'
                        ? stack.slice(0, -1)
                        : [...stack.slice(0, -1), ...stackPush.split('')];
                    
                    if (this.acceptsEmptyStack({
                        state: nextState,
                        input: remainingInput,
                        stack: newStack
                    })) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
}

// 构造 a^n b^n 的 PDA
function createAnBnPDA() {
    const pda = new PDA();
    
    // δ(q₀, a, Z₀) = (q₀, aZ₀)
    pda.addTransition('q₀', 'a', 'Z₀', 'q₀', 'aZ₀');
    
    // δ(q₀, a, a) = (q₀, aa)
    pda.addTransition('q₀', 'a', 'a', 'q₀', 'aa');
    
    // δ(q₀, b, a) = (q₁, ε)
    pda.addTransition('q₀', 'b', 'a', 'q₁', 'ε');
    
    // δ(q₁, b, a) = (q₁, ε)
    pda.addTransition('q₁', 'b', 'a', 'q₁', 'ε');
    
    // ε-转移：检查栈是否只剩 Z₀
    pda.addTransition('q₁', 'ε', 'Z₀', 'q₂', 'Z₀');
    
    pda.setStartState('q₀');
    pda.setStartStackSymbol('Z₀');
    pda.addAcceptState('q₂');
    
    return pda;
}

// 构造平衡括号 PDA
function createBalancedParensPDA() {
    const pda = new PDA();
    
    // 遇到左括号，压入栈
    pda.addTransition('q₀', '(', 'Z₀', 'q₀', '(Z₀');
    pda.addTransition('q₀', '(', '(', 'q₀', '((');
    
    // 遇到右括号，弹出栈
    pda.addTransition('q₀', ')', '(', 'q₀', 'ε');
    
    // ε-转移：检查栈是否只剩 Z₀
    pda.addTransition('q₀', 'ε', 'Z₀', 'q₀', 'Z₀');
    
    pda.setStartState('q₀');
    pda.setStartStackSymbol('Z₀');
    pda.addAcceptState('q₀');
    
    return pda;
}

// 测试
console.log('=== a^n b^n PDA 测试 ===');
const anbnPDA = createAnBnPDA();
const testStrings1 = ['ab', 'aabb', 'aaabbb', 'aaaabbbb', 'aab', 'abb', 'abbb'];
testStrings1.forEach(str => {
    const result = anbnPDA.acceptsByState(str);
    console.log(`  "${str}": ${result ? '接受' : '拒绝'}`);
});

console.log('\n=== 平衡括号 PDA 测试 ===');
const parensPDA = createBalancedParensPDA();
const testStrings2 = ['()', '(())', '()()', '((()))', '(()', '())', ')(', '(()))('];
testStrings2.forEach(str => {
    const result = parensPDA.acceptsByEmptyStack(str);
    console.log(`  "${str}": ${result ? '接受' : '拒绝'}`);
});
                            </code></pre>
                        </div>
                    </div>
                    <div id="pda-python" class="code-tab-content">
                        <div class="code-block line-numbers">
                            <pre><code class="language-python">
class PDA:
    def __init__(self):
        self.states = set()
        self.input_alphabet = set()
        self.stack_alphabet = set()
        self.transitions = {}  # (state, input, stack_top) -> [(next_state, stack_push), ...]
        self.start_state = None
        self.start_stack_symbol = None
        self.accept_states = set()
    
    def add_transition(self, state, input_sym, stack_top, next_state, stack_push):
        key = (state, input_sym, stack_top)
        if key not in self.transitions:
            self.transitions[key] = []
        self.transitions[key].append((next_state, stack_push))
        
        self.states.add(state)
        self.states.add(next_state)
        self.input_alphabet.add(input_sym)
        for s in stack_push:
            self.stack_alphabet.add(s)
    
    def set_start_state(self, state):
        self.start_state = state
    
    def set_start_stack_symbol(self, symbol):
        self.start_stack_symbol = symbol
    
    def add_accept_state(self, state):
        self.accept_states.add(state)
    
    def accepts_by_state(self, input_str):
        config = {
            'state': self.start_state,
            'input': input_str,
            'stack': [self.start_stack_symbol]
        }
        return self._accepts_final_state(config)
    
    def accepts_by_empty_stack(self, input_str):
        config = {
            'state': self.start_state,
            'input': input_str,
            'stack': [self.start_stack_symbol]
        }
        return self._accepts_empty_stack(config)
    
    def _accepts_final_state(self, config):
        state, input_str, stack = config['state'], config['input'], config['stack']
        
        # 基础情况
        if len(input_str) == 0:
            return state in self.accept_states
        
        current_input = input_str[0]
        remaining_input = input_str[1:]
        stack_top = stack[-1]
        
        # 尝试 ε 转移
        epsilon_key = (state, 'ε', stack_top)
        if epsilon_key in self.transitions:
            for next_state, stack_push in self.transitions[epsilon_key]:
                new_stack = stack[:-1] + list(stack_push)
                if self._accepts_final_state({
                    'state': next_state,
                    'input': input_str,
                    'stack': new_stack
                }):
                    return True
        
        # 尝试普通转移
        normal_key = (state, current_input, stack_top)
        if normal_key in self.transitions:
            for next_state, stack_push in self.transitions[normal_key]:
                new_stack = stack[:-1] + list(stack_push)
                if self._accepts_final_state({
                    'state': next_state,
                    'input': remaining_input,
                    'stack': new_stack
                }):
                    return True
        
        return False
    
    def _accepts_empty_stack(self, config):
        state, input_str, stack = config['state'], config['input'], config['stack']
        
        # 基础情况：栈为空（只剩初始符号）且输入为空
        if len(input_str) == 0 and len(stack) == 1 and stack[0] == self.start_stack_symbol:
            return True
        
        if len(stack) == 0:
            return False
        
        current_input = input_str[0] if input_str else 'ε'
        remaining_input = input_str[1:] if input_str else ''
        stack_top = stack[-1]
        
        # 尝试 ε 转移
        epsilon_key = (state, 'ε', stack_top)
        if epsilon_key in self.transitions:
            for next_state, stack_push in self.transitions[epsilon_key]:
                new_stack = stack[:-1] if stack_push == 'ε' else stack[:-1] + list(stack_push)
                if self._accepts_empty_stack({
                    'state': next_state,
                    'input': input_str,
                    'stack': new_stack
                }):
                    return True
        
        # 尝试普通转移
        if input_str:
            normal_key = (state, current_input, stack_top)
            if normal_key in self.transitions:
                for next_state, stack_push in self.transitions[normal_key]:
                    new_stack = stack[:-1] if stack_push == 'ε' else stack[:-1] + list(stack_push)
                    if self._accepts_empty_stack({
                        'state': next_state,
                        'input': remaining_input,
                        'stack': new_stack
                    }):
                        return True
        
        return False


def create_an_bn_pda():
    """构造识别 a^n b^n 的 PDA"""
    pda = PDA()
    
    # δ(q₀, a, Z₀) = (q₀, aZ₀)
    pda.add_transition('q₀', 'a', 'Z₀', 'q₀', 'aZ₀')
    
    # δ(q₀, a, a) = (q₀, aa)
    pda.add_transition('q₀', 'a', 'a', 'q₀', 'aa')
    
    # δ(q₀, b, a) = (q₁, ε)
    pda.add_transition('q₀', 'b', 'a', 'q₁', 'ε')
    
    # δ(q₁, b, a) = (q₁, ε)
    pda.add_transition('q₁', 'b', 'a', 'q₁', 'ε')
    
    # ε-转移
    pda.add_transition('q₁', 'ε', 'Z₀', 'q₂', 'Z₀')
    
    pda.set_start_state('q₀')
    pda.set_start_stack_symbol('Z₀')
    pda.add_accept_state('q₂')
    
    return pda


def create_balanced_parens_pda():
    """构造识别平衡括号的 PDA"""
    pda = PDA()
    
    # 遇到左括号，压入栈
    pda.add_transition('q₀', '(', 'Z₀', 'q₀', '(Z₀')
    pda.add_transition('q₀', '(', '(', 'q₀', '((')
    
    # 遇到右括号，弹出栈
    pda.add_transition('q₀', ')', '(', 'q₀', 'ε')
    
    # ε-转移：检查栈是否只剩 Z₀
    pda.add_transition('q₀', 'ε', 'Z₀', 'q₀', 'Z₀')
    
    pda.set_start_state('q₀')
    pda.set_start_stack_symbol('Z₀')
    pda.add_accept_state('q₀')
    
    return pda


if __name__ == "__main__":
    print("=== a^n b^n PDA 测试 ===")
    anbn_pda = create_an_bn_pda()
    test_strings = ['ab', 'aabb', 'aaabbb', 'aaaabbbb', 'aab', 'abb', 'abbb']
    for s in test_strings:
        result = anbn_pda.accepts_by_state(s)
        print(f'  "{s}": {"接受" if result else "拒绝"}')
    
    print("\n=== 平衡括号 PDA 测试 ===")
    parens_pda = create_balanced_parens_pda()
    test_strings = ['()', '(())', '()()', '((()))', '(()', '())', ')(', '(()))(']
    for s in test_strings:
        result = parens_pda.accepts_by_empty_stack(s)
        print(f'  "{s}": {"接受" if result else "拒绝"}')
                            </code></pre>
                        </div>
                    </div>
                    <div id="pda-go" class="code-tab-content">
                        <div class="code-block line-numbers">
                            <pre><code class="language-go">
package main

import (
    "fmt"
    "strings"
)

type PDA struct {
    states           map[string]bool
    inputAlphabet    map[string]bool
    stackAlphabet    map[string]bool
    transitions      map[string][]string
    startState       string
    startStackSymbol string
    acceptStates     map[string]bool
}

func NewPDA() *PDA {
    return &PDA{
        states:       make(map[string]bool),
        inputAlphabet: make(map[string]bool),
        stackAlphabet: make(map[string]bool),
        transitions:  make(map[string][]string),
        acceptStates: make(map[string]bool),
    }
}

func (pda *PDA) addTransition(state, input, stackTop, nextState, stackPush string) {
    key := fmt.Sprintf("%s:%s:%s", state, input, stackTop)
    pda.transitions[key] = append(pda.transitions[key], fmt.Sprintf("%s:%s", nextState, stackPush))
    
    pda.states[state] = true
    pda.states[nextState] = true
    pda.inputAlphabet[input] = true
    for _, r := range stackPush {
        pda.stackAlphabet[string(r)] = true
    }
}

func (pda *PDA) setStartState(state string) {
    pda.startState = state
}

func (pda *PDA) setStartStackSymbol(symbol string) {
    pda.startStackSymbol = symbol
}

func (pda *PDA) addAcceptState(state string) {
    pda.acceptStates[state] = true
}

func (pda *PDA) acceptsByState(input string) bool {
    config := map[string]interface{}{
        "state": pda.startState,
        "input": input,
        "stack": []string{pda.startStackSymbol},
    }
    return pda.acceptsFinalState(config)
}

func (pda *PDA) acceptsByEmptyStack(input string) bool {
    config := map[string]interface{}{
        "state": pda.startState,
        "input": input,
        "stack": []string{pda.startStackSymbol},
    }
    return pda.acceptsEmptyStack(config)
}

func (pda *PDA) acceptsFinalState(config map[string]interface{}) bool {
    state := config["state"].(string)
    input := config["input"].(string)
    stack := config["stack"].([]string)
    
    // 基础情况
    if len(input) == 0 {
        return pda.acceptStates[state]
    }
    
    currentInput := input[0]
    remainingInput := input[1:]
    stackTop := stack[len(stack)-1]
    
    // 尝试 ε 转移
    epsilonKey := fmt.Sprintf("%s:ε:%s", state, stackTop)
    if trans, ok := pda.transitions[epsilonKey]; ok {
        for _, t := range trans {
            parts := strings.Split(t, ":")
            nextState := parts[0]
            stackPush := parts[1]
            newStack := append(stack[:len(stack)-1], splitString(stackPush)...)
            newConfig := map[string]interface{}{
                "state": nextState,
                "input": input,
                "stack": newStack,
            }
            if pda.acceptsFinalState(newConfig) {
                return true
            }
        }
    }
    
    // 尝试普通转移
    normalKey := fmt.Sprintf("%s:%c:%s", state, currentInput, stackTop)
    if trans, ok := pda.transitions[normalKey]; ok {
        for _, t := range trans {
            parts := strings.Split(t, ":")
            nextState := parts[0]
            stackPush := parts[1]
            newStack := append(stack[:len(stack)-1], splitString(stackPush)...)
            newConfig := map[string]interface{}{
                "state": nextState,
                "input": remainingInput,
                "stack": newStack,
            }
            if pda.acceptsFinalState(newConfig) {
                return true
            }
        }
    }
    
    return false
}

func (pda *PDA) acceptsEmptyStack(config map[string]interface{}) bool {
    state := config["state"].(string)
    input := config["input"].(string)
    stack := config["stack"].([]string)
    
    // 基础情况：栈为空（只剩初始符号）且输入为空
    if len(input) == 0 && len(stack) == 1 && stack[0] == pda.startStackSymbol {
        return true
    }
    
    if len(stack) == 0 {
        return false
    }
    
    currentInput := ' '
    remainingInput := ""
    if len(input) > 0 {
        currentInput = rune(input[0])
        remainingInput = input[1:]
    }
    stackTop := stack[len(stack)-1]
    
    // 尝试 ε 转移
    epsilonKey := fmt.Sprintf("%s:ε:%s", state, stackTop)
    if trans, ok := pda.transitions[epsilonKey]; ok {
        for _, t := range trans {
            parts := strings.Split(t, ":")
            nextState := parts[0]
            stackPush := parts[1]
            var newStack []string
            if stackPush == "ε" {
                newStack = stack[:len(stack)-1]
            } else {
                newStack = append(stack[:len(stack)-1], splitString(stackPush)...)
            }
            newConfig := map[string]interface{}{
                "state": nextState,
                "input": input,
                "stack": newStack,
            }
            if pda.acceptsEmptyStack(newConfig) {
                return true
            }
        }
    }
    
    // 尝试普通转移
    if len(input) > 0 {
        normalKey := fmt.Sprintf("%s:%c:%s", state, currentInput, stackTop)
        if trans, ok := pda.transitions[normalKey]; ok {
            for _, t := range trans {
                parts := strings.Split(t, ":")
                nextState := parts[0]
                stackPush := parts[1]
                var newStack []string
                if stackPush == "ε" {
                    newStack = stack[:len(stack)-1]
                } else {
                    newStack = append(stack[:len(stack)-1], splitString(stackPush)...)
                }
                newConfig := map[string]interface{}{
                    "state": nextState,
                    "input": remainingInput,
                    "stack": newStack,
                }
                if pda.acceptsEmptyStack(newConfig) {
                    return true
                }
            }
        }
    }
    
    return false
}

func splitString(s string) []string {
    if s == "ε" || s == "" {
        return []string{}
    }
    result := make([]string, len(s))
    for i, r := range s {
        result[i] = string(r)
    }
    return result
}

func createAnBnPDA() *PDA {
    pda := NewPDA()
    
    // δ(q₀, a, Z₀) = (q₀, aZ₀)
    pda.addTransition("q0", "a", "Z0", "q0", "aZ0")
    
    // δ(q₀, a, a) = (q₀, aa)
    pda.addTransition("q0", "a", "a", "q0", "aa")
    
    // δ(q₀, b, a) = (q₁, ε)
    pda.addTransition("q0", "b", "a", "q1", "ε")
    
    // δ(q₁, b, a) = (q₁, ε)
    pda.addTransition("q1", "b", "a", "q1", "ε")
    
    // ε-转移
    pda.addTransition("q1", "ε", "Z0", "q2", "Z0")
    
    pda.setStartState("q0")
    pda.setStartStackSymbol("Z0")
    pda.addAcceptState("q2")
    
    return pda
}

func createBalancedParensPDA() *PDA {
    pda := NewPDA()
    
    // 遇到左括号，压入栈
    pda.addTransition("q0", "(", "Z0", "q0", "(Z0")
    pda.addTransition("q0", "(", "(", "q0", "((")
    
    // 遇到右括号，弹出栈
    pda.addTransition("q0", ")", "(", "q0", "ε")
    
    // ε-转移
    pda.addTransition("q0", "ε", "Z0", "q0", "Z0")
    
    pda.setStartState("q0")
    pda.setStartStackSymbol("Z0")
    pda.addAcceptState("q0")
    
    return pda
}

func main() {
    fmt.Println("=== a^n b^n PDA 测试 ===")
    anbnPDA := createAnBnPDA()
    testStrings := []string{"ab", "aabb", "aaabbb", "aaaabbbb", "aab", "abb", "abbb"}
    for _, s := range testStrings {
        result := "拒绝"
        if anbnPDA.acceptsByState(s) {
            result = "接受"
        }
        fmt.Printf("  \"%s\": %s\n", s, result)
    }
    
    fmt.Println("\n=== 平衡括号 PDA 测试 ===")
    parensPDA := createBalancedParensPDA()
    testStrings = []string{"()", "(())", "()()", "((()))", "(()", "())", ")(", "(()))("}
    for _, s := range testStrings {
        result := "拒绝"
        if parensPDA.acceptsByEmptyStack(s) {
            result = "接受"
        }
        fmt.Printf("  \"%s\": %s\n", s, result)
    }
}
                            </code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <h2>PDA vs FSA</h2>
            <div class="algorithm-content">
                <table class="comparison-table">
                    <tr>
                        <th>特性</th>
                        <th>有限自动机 (FSA)</th>
                        <th>下推自动机 (PDA)</th>
                    </tr>
                    <tr>
                        <td>存储</td>
                        <td>无 (仅有限状态)</td>
                        <td>栈 (无限深度)</td>
                    </tr>
                    <tr>
                        <td>识别能力</td>
                        <td>正则语言</td>
                        <td>上下文无关语言</td>
                    </tr>
                    <tr>
                        <td>典型应用</td>
                        <td>正则匹配、词法分析</td>
                        <td>语法分析、表达式求值</td>
                    </tr>
                    <tr>
                        <td>能识别 aⁿbⁿ</td>
                        <td>否</td>
                        <td>是</td>
                    </tr>
                    <tr>
                        <td>能识别平衡括号</td>
                        <td>否</td>
                        <td>是</td>
                    </tr>
                </table>
            </div>

            <h2>应用场景</h2>
            <div class="algorithm-content">
                <h3>1. 语法分析</h3>
                <p>PDA 是上下文无关文法 (CFG) 的计算模型，用于编译器的语法分析阶段。</p>
                
                <h3>2. 表达式求值</h3>
                <p>利用栈处理运算符优先级，识别中缀表达式的括号匹配。</p>
                
                <h3>3. XML/JSON 解析</h3>
                <p>识别嵌套的标签或括号结构。</p>
                
                <h3>4. 算术表达式验证</h3>
                <p>检查表达式中的括号是否匹配。</p>
                
                <h3>5. 编译器设计</h3>
                <p>递归下降分析器和 LR 分析器的理论基础。</p>
            </div>

            <h2>上下文无关语言示例</h2>
            <div class="algorithm-content">
                <p>以下语言都可以用 PDA 识别：</p>
                <ul>
                    <li><strong>{aⁿbⁿ | n ≥ 1}</strong> - n个a后跟n个b</li>
                    <li><strong>{wwᴿ | w ∈ {a,b}*}</strong> - 回文串</li>
                    <li><strong>平衡括号</strong> - ()、(()())、((())) 等</li>
                    <li><strong>{aⁱbʲcᵏ | i=j 或 j=k}</strong> - 复杂的嵌套匹配</li>
                </ul>
            </div>

            <h2>总结：下推自动机的核心洞察</h2>
            <div class="concept-box">
                <h4>关键创新</h4>
                <ol>
                    <li><strong>栈式存储</strong>：后进先出的数据结构提供了嵌套计数能力</li>
                    <li><strong>状态+栈</strong>：有限状态控制 + 无限存储 = 强大的计算能力</li>
                    <li><strong>上下文无关</strong>：栈操作不依赖于远程上下文</li>
                    <li><strong>CFG 等价</strong>：PDA 与上下文无关文法具有相同的表达能力</li>
                    <li><strong>编译器基础</strong>：语法分析和表达式处理的核心模型</li>
                </ol>
            </div>

            <h3>学习建议</h3>
            <div class="algorithm-content">
                <ul>
                    <li>理解 PDA 的七元组定义和各组成部分</li>
                    <li>掌握转移函数的三元组形式 δ(q, a, X)</li>
                    <li>手工设计 PDA 识别 aⁿbⁿ 和平衡括号</li>
                    <li>理解空栈接受和最终状态接受的等价性</li>
                    <li>学习 PDA 与上下文无关文法的对应关系</li>
                    <li>了解 LR 分析器如何利用 PDA 思想进行语法分析</li>
                </ul>
            </div>
        </div>
    </section>

    <script src="../js/main.js"></script>
    <script src="../lib/prism/prism.min.js"></script>
    <script src="../lib/prism/prism-python.min.js"></script>
    <script src="../lib/prism/prism-go.min.js"></script>
    <script src="../lib/prism/prism-line-numbers.min.js"></script>
</body>
</html>

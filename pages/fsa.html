<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ‰é™çŠ¶æ€è‡ªåŠ¨æœº - ç®—æ³•å­¦ä¹ æŒ‡å—</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../lib/prism/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../lib/prism/prism-line-numbers.min.css">
    <style>
        .fsm-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            margin: 30px 0;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
        }
        
        .state-row {
            display: flex;
            align-items: center;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .state {
            width: 70px;
            height: 70px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: #2c3e50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            position: relative;
            border: 3px solid transparent;
        }
        
        .state.start {
            border-color: #2ecc71;
        }
        
        .state.accept {
            border-color: #e74c3c;
        }
        
        .state.accept::after {
            content: '';
            position: absolute;
            width: 80px;
            height: 80px;
            border: 3px solid #e74c3c;
            border-radius: 50%;
            top: -9px;
            left: -9px;
        }
        
        .state.current {
            background: #3498db;
            color: white;
        }
        
        .transition-arrow {
            font-size: 30px;
            color: white;
        }
        
        .transition-line {
            position: absolute;
            height: 3px;
            background: rgba(255,255,255,0.7);
            transform-origin: left center;
        }
        
        .state-label {
            color: white;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .transition-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .transition-table th,
        .transition-table td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .transition-table th {
            background: #3498db;
            color: white;
        }
        
        .transition-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .highlight-text {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .concept-box {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .math-formula {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
            border-radius: 0 8px 8px 0;
        }
        
        .nfa-dfa-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }
        
        .automaton-type {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }
        
        .automaton-type h4 {
            color: #3498db;
            margin-bottom: 15px;
        }
        
        .example-pattern {
            background: #0d1117;
            color: #c9d1d9;
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            margin: 15px 0;
            border: 1px solid #30363d;
        }
        
        .regex-visual {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .regex-token {
            background: #3498db;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .regex-token.operator {
            background: #e74c3c;
        }
        
        .regex-token.paren {
            background: #9b59b6;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <h1 class="logo">AlgoLearn</h1>
            <ul class="nav-links">
                <li><a href="../index.html">é¦–é¡µ</a></li>
                <li><a href="../index.html#algorithms">ç®—æ³•åˆ†ç±»</a></li>
            </ul>
        </div>
    </nav>

    <section class="algorithm-detail">
        <div class="container">
            <a href="../index.html#algorithms" class="back-link">â† è¿”å›ç®—æ³•åˆ†ç±»</a>
            <h2>æœ‰é™çŠ¶æ€è‡ªåŠ¨æœº (FSA/FA)</h2>
            
            <div class="algorithm-content">
                <h3>ä»€ä¹ˆæ˜¯æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼Ÿ</h3>
                <p>
                    <strong>æœ‰é™çŠ¶æ€è‡ªåŠ¨æœº (Finite State Automaton, FSA)</strong> 
                    æ˜¯ä¸€ç§æŠ½è±¡çš„è®¡ç®—æ¨¡å‹ï¼Œç”±æœ‰é™ä¸ªçŠ¶æ€ç»„æˆï¼Œé€šè¿‡æ¥æ”¶è¾“å…¥ç¬¦å·åœ¨çŠ¶æ€ä¹‹é—´è½¬ç§»ã€‚
                    å®ƒæ˜¯æ­£åˆ™è¯­è¨€çš„å½¢å¼åŒ–æè¿°ï¼Œå¹¿æ³›åº”ç”¨äºç¼–è¯‘å™¨ã€æ–‡æœ¬å¤„ç†ã€ç½‘ç»œåè®®ç­‰é¢†åŸŸã€‚
                </p>
                <p>
                    æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š<span class="highlight-text">
                    é€šè¿‡æœ‰é™çš„çŠ¶æ€é›†åˆå’ŒçŠ¶æ€è½¬ç§»è§„åˆ™æ¥è¯†åˆ«è¯­è¨€ä¸­çš„å­—ç¬¦ä¸²</span>ã€‚
                </p>
            </div>

            <div class="complexity">
                <div class="complexity-item">
                    <h4>ç©ºé—´å¤æ‚åº¦</h4>
                    <p>O(|Q|) - çŠ¶æ€æ•°</p>
                </div>
                <div class="complexity-item">
                    <h4>æ—¶é—´å¤æ‚åº¦</h4>
                    <p>O(n) - å­—ç¬¦ä¸²é•¿åº¦</p>
                </div>
                <div class="complexity-item">
                    <h4>è¯†åˆ«èƒ½åŠ›</h4>
                    <p>æ­£åˆ™è¯­è¨€</p>
                </div>
            </div>

            <h2>å½¢å¼åŒ–å®šä¹‰</h2>
            <div class="algorithm-content">
                <p>ä¸€ä¸ªç¡®å®šæœ‰é™è‡ªåŠ¨æœº (DFA) æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š</p>
                <div class="math-formula">
                    <p><strong>M = (Q, Î£, Î´, qâ‚€, F)</strong></p>
                    <br>
                    <p>å…¶ä¸­ï¼š</p>
                    <p>â€¢ <strong>Q</strong> = æœ‰é™çŠ¶æ€é›†åˆ {qâ‚€, qâ‚, ..., qâ‚™}</p>
                    <p>â€¢ <strong>Î£</strong> = è¾“å…¥å­—æ¯è¡¨ (æœ‰é™ç¬¦å·é›†)</p>
                    <p>â€¢ <strong>Î´</strong> = çŠ¶æ€è½¬ç§»å‡½æ•° Q Ã— Î£ â†’ Q</p>
                    <p>â€¢ <strong>qâ‚€</strong> = åˆå§‹çŠ¶æ€ (qâ‚€ âˆˆ Q)</p>
                    <p>â€¢ <strong>F</strong> = æ¥å—çŠ¶æ€é›†åˆ (F âŠ† Q)</p>
                </div>
            </div>

            <h2>DFA ç¤ºä¾‹ï¼šè¯†åˆ«äºŒè¿›åˆ¶å¶æ•°</h2>
            <div class="fsm-diagram">
                <p style="color: white; font-weight: bold;">è¯†åˆ«è§„åˆ™ï¼šä»¥ 0 ç»“å°¾çš„äºŒè¿›åˆ¶æ•°</p>
                <div class="state-row">
                    <div style="text-align: center;">
                        <div class="state start accept">qâ‚€</div>
                        <div class="state-label">å¶æ•° (åˆå§‹/æ¥å—)</div>
                    </div>
                    <div class="transition-arrow">0 â†’</div>
                    <div style="text-align: center;">
                        <div class="state accept">qâ‚€</div>
                        <div class="state-label">ä¿æŒå¶æ•°</div>
                    </div>
                    <div class="transition-arrow">1 â†’</div>
                    <div style="text-align: center;">
                        <div class="state">qâ‚</div>
                        <div class="state-label">å¥‡æ•°</div>
                    </div>
                    <div class="transition-arrow">0 â†’</div>
                    <div style="text-align: center;">
                        <div class="state accept">qâ‚€</div>
                        <div class="state-label">å˜å¶æ•°</div>
                    </div>
                </div>
            </div>

            <h3>çŠ¶æ€è½¬ç§»è¡¨</h3>
            <div class="algorithm-content">
                <table class="transition-table">
                    <tr>
                        <th>çŠ¶æ€</th>
                        <th>è¾“å…¥ 0</th>
                        <th>è¾“å…¥ 1</th>
                    </tr>
                    <tr>
                        <td>qâ‚€ (åˆå§‹/æ¥å—)</td>
                        <td>qâ‚€</td>
                        <td>qâ‚</td>
                    </tr>
                    <tr>
                        <td>qâ‚</td>
                        <td>qâ‚€</td>
                        <td>qâ‚</td>
                    </tr>
                </table>
            </div>

            <h2>NFA vs DFA</h2>
            <div class="nfa-dfa-comparison">
                <div class="automaton-type">
                    <h4>DFA (ç¡®å®šæœ‰é™è‡ªåŠ¨æœº)</h4>
                    <ul>
                        <li>æ¯ä¸ªçŠ¶æ€å¯¹æ¯ä¸ªè¾“å…¥æœ‰<strong>å”¯ä¸€</strong>è½¬ç§»</li>
                        <li>Îµè½¬ç§»ï¼š<strong>ä¸å…è®¸</strong></li>
                        <li>çŠ¶æ€è½¬ç§»æ˜¯ç¡®å®šçš„</li>
                        <li>å®ç°ç®€å•ï¼Œæ•ˆç‡é«˜</li>
                    </ul>
                    <div class="example-pattern">
                        ç¤ºä¾‹ï¼šè¯†åˆ« a(b|c)*
                    </div>
                </div>
                <div class="automaton-type">
                    <h4>NFA (ä¸ç¡®å®šæœ‰é™è‡ªåŠ¨æœº)</h4>
                    <ul>
                        <li>æ¯ä¸ªçŠ¶æ€å¯¹æ¯ä¸ªè¾“å…¥å¯èƒ½æœ‰<strong>å¤šä¸ª</strong>è½¬ç§»</li>
                        <li>Îµè½¬ç§»ï¼š<strong>å…è®¸</strong></li>
                        <li>çŠ¶æ€è½¬ç§»æ˜¯ä¸ç¡®å®šçš„</li>
                        <li>ç»“æ„æ›´ç›´è§‚ï¼Œæ˜“äºæ„é€ </li>
                    </ul>
                    <div class="example-pattern">
                        ç¤ºä¾‹ï¼šè¯†åˆ« (a|b)*abb
                    </div>
                </div>
            </div>

            <h2>æ­£åˆ™è¡¨è¾¾å¼ä¸è‡ªåŠ¨æœº</h2>
            <div class="algorithm-content">
                <p>æ­£åˆ™è¡¨è¾¾å¼å¯ä»¥è½¬æ¢ä¸ºç­‰ä»·çš„ DFAï¼Œè¿™æ˜¯æ­£åˆ™è¡¨è¾¾å¼å¼•æ“çš„æ ¸å¿ƒåŸç†ã€‚</p>
                
                <h3>è½¬æ¢ç¤ºä¾‹ï¼ša(b|c)*</h3>
                <div class="regex-visual">
                    <div class="regex-token">a</div>
                    <div class="regex-token operator">|</div>
                    <div class="regex-token">b</div>
                    <div class="regex-token operator">|</div>
                    <div class="regex-token">c</div>
                    <div class="regex-token">*</div>
                </div>
                
                <div class="concept-box">
                    <h4>è½¬æ¢æ­¥éª¤</h4>
                    <ol>
                        <li>æ ¹æ®æ­£åˆ™è¡¨è¾¾å¼æ„å»ºè¯­æ³•æ ‘</li>
                        <li>ä½¿ç”¨ Thompson æ„é€ æ³•æ„å»º NFA</li>
                        <li>ä½¿ç”¨å­é›†æ„é€ æ³•å°† NFA è½¬æ¢ä¸º DFA</li>
                        <li>å¯¹ DFA è¿›è¡ŒçŠ¶æ€æœ€å°åŒ–</li>
                    </ol>
                </div>
            </div>

            <h2>å®Œæ•´å®ç°</h2>
            <div class="algorithm-content">
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="fsa-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="fsa-python">Python</button>
                        <button class="code-tab-btn" data-tab="fsa-go">Go</button>
                    </div>
                    <div id="fsa-js" class="code-tab-content active">
                        <div class="code-block line-numbers">
                            <pre><code class="language-javascript">
class DFA {
    constructor() {
        this.states = new Set();
        this.alphabet = new Set();
        this.transitions = new Map();
        this.startState = null;
        this.acceptStates = new Set();
    }
    
    addState(state) {
        this.states.add(state);
    }
    
    setStartState(state) {
        this.startState = state;
    }
    
    addAcceptState(state) {
        this.acceptStates.add(state);
    }
    
    addTransition(fromState, symbol, toState) {
        const key = `${fromState}:${symbol}`;
        this.transitions.set(key, toState);
        this.alphabet.add(symbol);
    }
    
    // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦è¢«æ¥å—
    accepts(input) {
        let currentState = this.startState;
        
        for (const char of input) {
            const key = `${currentState}:${char}`;
            const nextState = this.transitions.get(key);
            
            if (nextState === undefined) {
                return false; // æ— æ•ˆè½¬ç§»
            }
            
            currentState = nextState;
        }
        
        return this.acceptStates.has(currentState);
    }
    
    // è·å–è½¬ç§»å‡½æ•°
    getTransition(state, symbol) {
        return this.transitions.get(`${state}:${symbol}`);
    }
    
    // å…‹éš† DFA
    clone() {
        const newDFA = new DFA();
        newDFA.states = new Set(this.states);
        newDFA.alphabet = new Set(this.alphabet);
        newDFA.transitions = new Map(this.transitions);
        newDFA.startState = this.startState;
        newDFA.acceptStates = new Set(this.acceptStates);
        return newDFA;
    }
}

// NFA ç±»ï¼ˆæ”¯æŒ Îµ è½¬ç§»å’Œå¤šå€¼è½¬ç§»ï¼‰
class NFA {
    constructor() {
        this.states = new Set();
        this.alphabet = new Set();
        this.epsilonTransitions = new Map();
        this.transitions = new Map();
        this.startStates = new Set();
        this.acceptStates = new Set();
    }
    
    addState(state) {
        this.states.add(state);
    }
    
    addStartState(state) {
        this.startStates.add(state);
    }
    
    addAcceptState(state) {
        this.acceptStates.add(state);
    }
    
    addTransition(fromState, symbol, toState) {
        const key = `${fromState}:${symbol}`;
        if (!this.transitions.has(key)) {
            this.transitions.set(key, new Set());
        }
        this.transitions.get(key).add(toState);
        this.alphabet.add(symbol);
    }
    
    addEpsilonTransition(fromState, toState) {
        if (!this.epsilonTransitions.has(fromState)) {
            this.epsilonTransitions.set(fromState, new Set());
        }
        this.epsilonTransitions.get(fromState).add(toState);
    }
    
    // Îµ-é—­åŒ…è®¡ç®—
    epsilonClosure(states) {
        const closure = new Set(states);
        const stack = Array.from(states);
        
        while (stack.length > 0) {
            const state = stack.pop();
            
            const epsilonNext = this.epsilonTransitions.get(state);
            if (epsilonNext) {
                for (const next of epsilonNext) {
                    if (!closure.has(next)) {
                        closure.add(next);
                        stack.push(next);
                    }
                }
            }
        }
        
        return closure;
    }
    
    // NFA æ¥å—æ£€æŸ¥
    accepts(input) {
        let currentStates = this.epsilonClosure(this.startStates);
        
        for (const char of input) {
            const nextStates = new Set();
            
            for (const state of currentStates) {
                const key = `${state}:${char}`;
                const trans = this.transitions.get(key);
                if (trans) {
                    nextStates.add(...trans);
                }
            }
            
            currentStates = this.epsilonClosure(nextStates);
            
            if (currentStates.size === 0) {
                return false;
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æ¥å—çŠ¶æ€
        for (const state of currentStates) {
            if (this.acceptStates.has(state)) {
                return true;
            }
        }
        
        return false;
    }
}

// æ­£åˆ™è¡¨è¾¾å¼åˆ° NFA çš„è½¬æ¢ (Thompson æ„é€ æ³•)
class RegexToNFA {
    constructor() {
        this.stateCounter = 0;
    }
    
    newState() {
        return `q${this.stateCounter++}`;
    }
    
    // åŸºæœ¬æ­£åˆ™è¡¨è¾¾å¼ï¼ˆå•ä¸ªå­—ç¬¦ï¼‰
    basic(char) {
        const start = this.newState();
        const accept = this.newState();
        
        const nfa = {
            start: start,
            accept: accept,
            transitions: new Map(),
            epsilonTransitions: new Map()
        };
        
        nfa.transitions.set(`${start}:${char}`, new Set([accept]));
        
        return nfa;
    }
    
    // å¹¶è”ï¼ša|b
    union(nfa1, nfa2) {
        const start = this.newState();
        const accept = this.newState();
        
        const epsilon1 = new Set([nfa1.start, nfa2.start]);
        const epsilon2 = new Set([accept]);
        
        return {
            start: start,
            accept: accept,
            transitions: new Map([...nfa1.transitions, ...nfa2.transitions]),
            epsilonTransitions: new Map([
                [start, epsilon1],
                [nfa1.accept, epsilon2],
                [nfa2.accept, epsilon2]
            ])
        };
    }
    
    // è¿æ¥ï¼šab
    concat(nfa1, nfa2) {
        return {
            start: nfa1.start,
            accept: nfa2.accept,
            transitions: new Map([...nfa1.transitions, ...nfa2.transitions]),
            epsilonTransitions: new Map([[nfa1.accept, new Set([nfa2.start])]])
        };
    }
    
    // å…‹æ—é—­åŒ…ï¼ša*
    kleeneStar(nfa) {
        const start = this.newState();
        const accept = this.newState();
        
        const epsilon1 = new Set([nfa.start, accept]);
        const epsilon2 = new Set([accept]);
        
        return {
            start: start,
            accept: accept,
            transitions: new Map(nfa.transitions),
            epsilonTransitions: new Map([
                [start, epsilon1],
                [nfa.accept, epsilon2]
            ])
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const dfa = new DFA();
dfa.addState('q0');
dfa.addState('q1');
dfa.setStartState('q0');
dfa.addAcceptState('q0');

dfa.addTransition('q0', '0', 'q0');
dfa.addTransition('q0', '1', 'q1');
dfa.addTransition('q1', '0', 'q0');
dfa.addTransition('q1', '1', 'q1');

// æµ‹è¯•
const testStrings = ['0', '1', '00', '01', '10', '11', '000', '1010'];
console.log('DFA æµ‹è¯• (è¯†åˆ«ä»¥0ç»“å°¾çš„äºŒè¿›åˆ¶æ•°):');
testStrings.forEach(str => {
    console.log(`  "${str}": ${dfa.accepts(str) ? 'æ¥å—' : 'æ‹’ç»'}`);
});
                            </code></pre>
                        </div>
                    </div>
                    <div id="fsa-python" class="code-tab-content">
                        <div class="code-block line-numbers">
                            <pre><code class="language-python">
from collections import defaultdict


class DFA:
    def __init__(self):
        self.states = set()
        self.alphabet = set()
        self.transitions = defaultdict(dict)
        self.start_state = None
        self.accept_states = set()
    
    def add_state(self, state):
        self.states.add(state)
    
    def set_start_state(self, state):
        self.start_state = state
    
    def add_accept_state(self, state):
        self.accept_states.add(state)
    
    def add_transition(self, from_state, symbol, to_state):
        self.transitions[from_state][symbol] = to_state
        self.alphabet.add(symbol)
    
    def accepts(self, input_str):
        current_state = self.start_state
        
        for char in input_str:
            if char not in self.transitions[current_state]:
                return False
            current_state = self.transitions[current_state][char]
        
        return current_state in self.accept_states
    
    def get_transition(self, state, symbol):
        return self.transitions[state].get(symbol)


class NFA:
    def __init__(self):
        self.states = set()
        self.alphabet = set()
        self.epsilon_transitions = defaultdict(set)
        self.transitions = defaultdict(lambda: defaultdict(set))
        self.start_states = set()
        self.accept_states = set()
    
    def add_state(self, state):
        self.states.add(state)
    
    def add_start_state(self, state):
        self.start_states.add(state)
    
    def add_accept_state(self, state):
        self.accept_states.add(state)
    
    def add_transition(self, from_state, symbol, to_state):
        self.transitions[from_state][symbol].add(to_state)
        self.alphabet.add(symbol)
    
    def add_epsilon_transition(self, from_state, to_state):
        self.epsilon_transitions[from_state].add(to_state)
    
    def epsilon_closure(self, states):
        closure = set(states)
        stack = list(states)
        
        while stack:
            state = stack.pop()
            for next_state in self.epsilon_transitions[state]:
                if next_state not in closure:
                    closure.add(next_state)
                    stack.append(next_state)
        
        return closure
    
    def accepts(self, input_str):
        current_states = self.epsilon_closure(self.start_states)
        
        for char in input_str:
            next_states = set()
            for state in current_states:
                next_states.update(self.transitions[state][char])
            
            current_states = self.epsilon_closure(next_states)
            
            if not current_states:
                return False
        
        return bool(current_states & self.accept_states)


# æ­£åˆ™è¡¨è¾¾å¼åˆ° NFA è½¬æ¢
class RegexToNFA:
    def __init__(self):
        self.state_counter = 0
    
    def new_state(self):
        state = f"q{self.state_counter}"
        self.state_counter += 1
        return state
    
    def basic(self, char):
        start = self.new_state()
        accept = self.new_state()
        
        nfa = {
            'start': start,
            'accept': accept,
            'transitions': {start: {char: {accept}}},
            'epsilon': {}
        }
        
        return nfa
    
    def union(self, nfa1, nfa2):
        start = self.new_state()
        accept = self.new_state()
        
        transitions = {**nfa1['transitions'], **nfa2['transitions']}
        transitions[start] = {}
        transitions[nfa1['accept']] = {}
        transitions[nfa2['accept']] = {}
        
        epsilon = {start: {nfa1['start'], nfa2['accept']}}
        epsilon[nfa1['accept']] = {accept}
        epsilon[nfa2['accept']] = {accept}
        
        return {
            'start': start,
            'accept': accept,
            'transitions': transitions,
            'epsilon': epsilon
        }
    
    def concat(self, nfa1, nfa2):
        transitions = {**nfa1['transitions'], **nfa2['transitions']}
        transitions[nfa1['accept']] = {}
        
        return {
            'start': nfa1['start'],
            'accept': nfa2['accept'],
            'transitions': transitions,
            'epsilon': {}
        }
    
    def kleene_star(self, nfa):
        start = self.new_state()
        accept = self.new_state()
        
        transitions = dict(nfa['transitions'])
        transitions[start] = {}
        transitions[nfa['accept']] = {}
        
        epsilon = {
            start: {nfa['start'], accept},
            nfa['accept']: {accept}
        }
        
        return {
            'start': start,
            'accept': accept,
            'transitions': transitions,
            'epsilon': epsilon
        }


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # æ„å»º DFAï¼šè¯†åˆ«ä»¥ 0 ç»“å°¾çš„äºŒè¿›åˆ¶æ•°
    dfa = DFA()
    dfa.add_state('q0')
    dfa.add_state('q1')
    dfa.set_start_state('q0')
    dfa.add_accept_state('q0')
    
    dfa.add_transition('q0', '0', 'q0')
    dfa.add_transition('q0', '1', 'q1')
    dfa.add_transition('q1', '0', 'q0')
    dfa.add_transition('q1', '1', 'q1')
    
    # æµ‹è¯•
    test_strings = ['0', '1', '00', '01', '10', '11', '000', '1010']
    print('DFA æµ‹è¯• (è¯†åˆ«ä»¥0ç»“å°¾çš„äºŒè¿›åˆ¶æ•°):')
    for s in test_strings:
        print(f'  "{s}": {"æ¥å—" if dfa.accepts(s) else "æ‹’ç»"}')
                            </code></pre>
                        </div>
                    </div>
                    <div id="fsa-go" class="code-tab-content">
                        <div class="code-block line-numbers">
                            <pre><code class="language-go">
package main

import (
    "fmt"
)

type DFA struct {
    states      map[string]bool
    alphabet    map[string]bool
    transitions map[string]map[string]string
    startState  string
    acceptStates map[string]bool
}

func NewDFA() *DFA {
    return &DFA{
        states:       make(map[string]bool),
        alphabet:     make(map[string]bool),
        transitions:  make(map[string]map[string]string),
        acceptStates: make(map[string]bool),
    }
}

func (dfa *DFA) AddState(state string) {
    dfa.states[state] = true
    dfa.transitions[state] = make(map[string]string)
}

func (dfa *DFA) SetStartState(state string) {
    dfa.startState = state
}

func (dfa *DFA) AddAcceptState(state string) {
    dfa.acceptStates[state] = true
}

func (dfa *DFA) AddTransition(fromState, symbol, toState string) {
    dfa.states[fromState] = true
    dfa.states[toState] = true
    dfa.alphabet[symbol] = true
    dfa.transitions[fromState][symbol] = toState
}

func (dfa *DFA) Accepts(input string) bool {
    currentState := dfa.startState
    
    for _, char := range input {
        nextState, ok := dfa.transitions[currentState][string(char)]
        if !ok {
            return false
        }
        currentState = nextState
    }
    
    return dfa.acceptStates[currentState]
}

type NFA struct {
    states           map[string]bool
    alphabet         map[string]bool
    epsilonTransitions map[string][]string
    transitions      map[string]map[string][]string
    startStates      map[string]bool
    acceptStates     map[string]bool
}

func NewNFA() *NFA {
    return &NFA{
        states:       make(map[string]bool),
        alphabet:     make(map[string]bool),
        epsilonTransitions: make(map[string][]string),
        transitions:  make(map[string]map[string][]string),
        startStates:  make(map[string]bool),
        acceptStates: make(map[string]bool),
    }
}

func (nfa *NFA) AddState(state string) {
    nfa.states[state] = true
}

func (nfa *NFA) AddStartState(state string) {
    nfa.startStates[state] = true
}

func (nfa *NFA) AddAcceptState(state string) {
    nfa.acceptStates[state] = true
}

func (nfa *NFA) AddTransition(fromState, symbol, toState string) {
    nfa.states[fromState] = true
    nfa.states[toState] = true
    nfa.alphabet[symbol] = true
    
    if nfa.transitions[fromState] == nil {
        nfa.transitions[fromState] = make(map[string][]string)
    }
    nfa.transitions[fromState][symbol] = append(nfa.transitions[fromState][symbol], toState)
}

func (nfa *NFA) AddEpsilonTransition(fromState, toState string) {
    nfa.states[fromState] = true
    nfa.states[toState] = true
    nfa.epsilonTransitions[fromState] = append(nfa.epsilonTransitions[fromState], toState)
}

func (nfa *NFA) epsilonClosure(states map[string]bool) map[string]bool {
    closure := make(map[string]bool)
    var stack []string
    
    for s := range states {
        closure[s] = true
        stack = append(stack, s)
    }
    
    for len(stack) > 0 {
        state := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        
        for _, next := range nfa.epsilonTransitions[state] {
            if !closure[next] {
                closure[next] = true
                stack = append(stack, next)
            }
        }
    }
    
    return closure
}

func (nfa *NFA) Accepts(input string) bool {
    currentStates := nfa.epsilonClosure(nfa.startStates)
    
    for _, char := range input {
        nextStates := make(map[string]bool)
        
        for state := range currentStates {
            for _, next := range nfa.transitions[state][string(char)] {
                nextStates[next] = true
            }
        }
        
        currentStates = nfa.epsilonClosure(nextStates)
        
        if len(currentStates) == 0 {
            return false
        }
    }
    
    for state := range currentStates {
        if nfa.acceptStates[state] {
            return true
        }
    }
    
    return false
}

func main() {
    // æ„å»º DFAï¼šè¯†åˆ«ä»¥ 0 ç»“å°¾çš„äºŒè¿›åˆ¶æ•°
    dfa := NewDFA()
    dfa.AddState("q0")
    dfa.AddState("q1")
    dfa.SetStartState("q0")
    dfa.AddAcceptState("q0")
    
    dfa.AddTransition("q0", "0", "q0")
    dfa.AddTransition("q0", "1", "q1")
    dfa.AddTransition("q1", "0", "q0")
    dfa.AddTransition("q1", "1", "q1")
    
    // æµ‹è¯•
    testStrings := []string{"0", "1", "00", "01", "10", "11", "000", "1010"}
    fmt.Println("DFA æµ‹è¯• (è¯†åˆ«ä»¥0ç»“å°¾çš„äºŒè¿›åˆ¶æ•°):")
    for _, s := range testStrings {
        result := "æ‹’ç»"
        if dfa.Accepts(s) {
            result = "æ¥å—"
        }
        fmt.Printf("  \"%s\": %s\n", s, result)
    }
}
                            </code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <h2>åº”ç”¨åœºæ™¯</h2>
            <div class="algorithm-content">
                <h3>1. æ­£åˆ™è¡¨è¾¾å¼å¼•æ“</h3>
                <p>å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€çš„æ­£åˆ™è¡¨è¾¾å¼å®ç°åº•å±‚ä½¿ç”¨ NFA æˆ– DFAã€‚</p>
                
                <h3>2. è¯æ³•åˆ†æ</h3>
                <p>ç¼–è¯‘å™¨çš„å‰ç«¯ä½¿ç”¨æœ‰é™è‡ªåŠ¨æœºè¿›è¡Œè¯æ³•åˆ†æï¼Œè¯†åˆ«å…³é”®å­—ã€æ ‡è¯†ç¬¦ç­‰ã€‚</p>
                
                <h3>3. ç½‘ç»œåè®®</h3>
                <p>TCP/IP åè®®æ ˆçš„çŠ¶æ€æœºå®ç°ç½‘ç»œè¿æ¥ç®¡ç†ã€‚</p>
                
                <h3>4. æ–‡æœ¬æœç´¢</h3>
                <p>grepã€sed ç­‰å·¥å…·ä½¿ç”¨æœ‰é™è‡ªåŠ¨æœºè¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚</p>
                
                <h3>5. æ¸¸æˆ AI</h3>
                <p>æœ‰é™çŠ¶æ€æœºç”¨äºå®ç°æ¸¸æˆè§’è‰²çš„è¡Œä¸ºé€»è¾‘ã€‚</p>
            </div>

            <h2>æœ‰é™è‡ªåŠ¨æœºçš„å±€é™æ€§</h2>
            <div class="algorithm-content">
                <div class="concept-box">
                    <h4>æ— æ³•è¯†åˆ«çš„è¯­è¨€</h4>
                    <ul>
                        <li><strong>aâ¿bâ¿</strong> (nä¸ªaåè·Ÿnä¸ªb) - éœ€è¦æ ˆæ¥è®¡æ•°</li>
                        <li><strong>å¹³è¡¡æ‹¬å·</strong> - éœ€è¦åµŒå¥—è®¡æ•°</li>
                        <li><strong>{ww | w âˆˆ Î£*}</strong> - éœ€è¦æ¯”è¾ƒä¸¤åŠ</li>
                    </ul>
                    <p style="margin-top: 10px;">
                        ğŸ’¡ è¿™äº›è¯­è¨€éœ€è¦ä¸‹æ¨è‡ªåŠ¨æœº (PDA) æˆ–æ›´å¼ºå¤§çš„è®¡ç®—æ¨¡å‹æ¥è¯†åˆ«
                    </p>
                </div>
            </div>

            <h2>æ€»ç»“ï¼šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºçš„æ ¸å¿ƒæ´å¯Ÿ</h2>
            <div class="concept-box">
                <h4>å…³é”®ç‰¹æ€§</h4>
                <ol>
                    <li><strong>æœ‰é™çŠ¶æ€</strong>ï¼šçŠ¶æ€æ•°é‡æ˜¯å›ºå®šçš„ï¼Œä¸éšè¾“å…¥å¢é•¿</li>
                    <li><strong>ç¡®å®šæ€§/éç¡®å®šæ€§</strong>ï¼šDFA çŠ¶æ€è½¬ç§»å”¯ä¸€ï¼ŒNFA å¯èƒ½æœ‰å¤šä¸ªé€‰æ‹©</li>
                    <li><strong>ç­‰ä»·æ€§</strong>ï¼šæ¯ä¸ª NFA éƒ½å¯ä»¥è½¬æ¢ä¸ºç­‰ä»·çš„ DFA</li>
                    <li><strong>æ­£åˆ™è¯­è¨€</strong>ï¼šæœ‰é™è‡ªåŠ¨æœºè¯†åˆ«çš„è¯­è¨€æ­£å¥½æ˜¯æ­£åˆ™è¯­è¨€</li>
                    <li><strong>é«˜æ•ˆè¯†åˆ«</strong>ï¼šå­—ç¬¦ä¸²è¯†åˆ«åªéœ€ O(n) æ—¶é—´</li>
                </ol>
            </div>

            <h3>å­¦ä¹ å»ºè®®</h3>
            <div class="algorithm-content">
                <ul>
                    <li>ç†è§£ DFA å’Œ NFA çš„å½¢å¼åŒ–å®šä¹‰</li>
                    <li>æŒæ¡çŠ¶æ€è½¬ç§»å›¾å’ŒçŠ¶æ€è½¬ç§»è¡¨çš„è¡¨ç¤ºæ–¹æ³•</li>
                    <li>å­¦ä¹  NFA åˆ° DFA çš„è½¬æ¢ï¼ˆå­é›†æ„é€ æ³•ï¼‰</li>
                    <li>ç†è§£æ­£åˆ™è¡¨è¾¾å¼åˆ° NFA çš„è½¬æ¢ï¼ˆThompson æ„é€ æ³•ï¼‰</li>
                    <li>äº†è§£æ­£åˆ™è¡¨è¾¾å¼çš„æ•ˆç‡é—®é¢˜å’Œå›æº¯æœºåˆ¶</li>
                    <li>å­¦ä¹ æœ‰é™è‡ªåŠ¨æœºåœ¨ç¼–è¯‘å™¨è¯æ³•åˆ†æä¸­çš„åº”ç”¨</li>
                </ul>
            </div>
        </div>
    </section>

    <script src="../js/main.js"></script>
    <script src="../lib/prism/prism.min.js"></script>
    <script src="../lib/prism/prism-python.min.js"></script>
    <script src="../lib/prism/prism-go.min.js"></script>
    <script src="../lib/prism/prism-line-numbers.min.js"></script>
</body>
</html>

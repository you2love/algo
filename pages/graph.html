<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图算法 - 算法学习指南</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../lib/prism/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../lib/prism/prism-line-numbers.min.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <h1 class="logo"></h1>
            <ul class="nav-links">
                <li><a href="../index.html">首页</a></li>
                <li><a href="../index.html#algorithms">算法分类</a></li>
                <li><a href="../index.html#practice">在线练习</a></li>
            </ul>
        </div>
    </nav>

    <section class="algorithm-detail">
        <div class="container">
            <a href="../index.html#algorithms" class="back-link">← 返回算法分类</a>
            <h2>图算法</h2>
            
            <div class="algorithm-content">
                <h3>什么是图算法？</h3>
                <p>图算法用于处理图结构数据，解决最短路径、最小生成树、拓扑排序等经典问题。</p>
            </div>

            <div class="complexity">
                <div class="complexity-item">
                    <h4>Dijkstra</h4>
                    <p>O((V+E)logV)</p>
                </div>
                <div class="complexity-item">
                    <h4>Floyd-Warshall</h4>
                    <p>O(V³)</p>
                </div>
                <div class="complexity-item">
                    <h4>Kruskal/Prim</h4>
                    <p>O(ElogV)</p>
                </div>
            </div>

            <h3>Dijkstra 最短路径算法</h3>
            <div class="algorithm-content">
                <p>在带权图中找到从起点到所有其他节点的最短路径，适用于权值为非负数的情况。</p>
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="dijkstra-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="dijkstra-python">Python</button>
                        <button class="code-tab-btn" data-tab="dijkstra-go">Go</button>
                    </div>
                    <div id="dijkstra-js" class="code-tab-content active">
                        <div class="code-block line-numbers"><pre><code class="language-javascript">
function dijkstra(graph, start) {
    const distances = {};
    const visited = new Set();
    const pq = new PriorityQueue();
    
    // 初始化
    for (const node in graph) {
        distances[node] = Infinity;
    }
    distances[start] = 0;
    pq.enqueue(start, 0);
    
    while (!pq.isEmpty()) {
        const { element: current } = pq.dequeue();
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        for (const neighbor in graph[current]) {
            const distance = distances[current] + graph[current][neighbor];
            
            if (distance < distances[neighbor]) {
                distances[neighbor] = distance;
                pq.enqueue(neighbor, distance);
            }
        }
    }
    
    return distances;
}

// 简单优先队列实现
class PriorityQueue {
    constructor() {
        this.items = [];
    }
    
    enqueue(element, priority) {
        this.items.push({ element, priority });
        this.items.sort((a, b) => a.priority - b.priority);
    }
    
    dequeue() {
        return this.items.shift();
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
}

// 测试
const graph = {
    A: { B: 4, C: 2 },
    B: { A: 4, C: 5, D: 10 },
    C: { A: 2, B: 5, D: 3 },
    D: { B: 10, C: 3 }
};
console.log(dijkstra(graph, 'A'));
// { A: 0, B: 4, C: 2, D: 5 }
                            </code></pre></div>
                    </div>
                    <div id="dijkstra-python" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-python">
import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    pq = [(0, start)]
    
    while pq:
        current_dist, current = heapq.heapp        
        if currentop(pq)
_dist > distances[current]:
            continue
        
        for neighbor, weight in graph[current].items():
            distance = current_dist + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    
    return distances

# 测试
graph = {
    'A': {'B': 4, 'C': 2},
    'B': {'A': 4, 'C': 5, 'D': 10},
    'C': {'A': 2, 'B': 5, 'D': 3},
    'D': {'B': 10, 'C': 3}
}
print(dijkstra(graph, 'A'))  # {'A': 0, 'B': 4, 'C': 2, 'D': 5}
                            </code></pre></div>
                    </div>
                    <div id="dijkstra-go" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-go">
package main

import (
    "container/heap"
    "fmt"
)

type Item struct {
    node     string
    distance int
    index    int
}

type PriorityQueue []*Item

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].distance < pq[j].distance
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
    pq[i].index = i
    pq[j].index = j
}

func (pq *PriorityQueue) Push(x interface{}) {
    item := x.(*Item)
    item.index = len(*pq)
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    old[n-1] = nil
    item.index = -1
    *pq = old[0 : n-1]
    return item
}

func (pq *PriorityQueue) update(item *Item, node string, distance int) {
    item.node = node
    item.distance = distance
    heap.Fix(pq, item.index)
}

func dijkstra(graph map[string]map[string]int, start string) map[string]int {
    distances := make(map[string]int)
    visited := make(map[string]bool)
    
    for node := range graph {
        distances[node] = 1 << 30
    }
    distances[start] = 0
    
    pq := &PriorityQueue{}
    heap.Init(pq)
    heap.Push(pq, &Item{node: start, distance: 0})
    
    for pq.Len() > 0 {
        item := heap.Pop(pq).(*Item)
        current := item.node
        currentDist := item.distance
        
        if visited[current] {
            continue
        }
        visited[current] = true
        
        for neighbor, weight := range graph[current] {
            if visited[neighbor] {
                continue
            }
            newDist := currentDist + weight
            if newDist < distances[neighbor] {
                distances[neighbor] = newDist
                heap.Push(pq, &Item{node: neighbor, distance: newDist})
            }
        }
    }
    
    return distances
}

func main() {
    graph := map[string]map[string]int{
        "A": {"B": 4, "C": 2},
        "B": {"A": 4, "C": 5, "D": 10},
        "C": {"A": 2, "B": 5, "D": 3},
        "D": {"B": 10, "C": 3},
    }
    fmt.Println(dijkstra(graph, "A"))  // map[A:0 B:4 C:2 D:5]
}
                            </code></pre></div>
                    </div>
                </div>
            </div>

            <h3>Floyd-Warshall 算法</h3>
            <div class="algorithm-content">
                <p>计算图中所有节点对之间的最短路径，适合解决多源最短路径问题。</p>
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="floyd-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="floyd-python">Python</button>
                        <button class="code-tab-btn" data-tab="floyd-go">Go</button>
                    </div>
                    <div id="floyd-js" class="code-tab-content active">
                        <div class="code-block line-numbers"><pre><code class="language-javascript">
function floydWarshall(graph) {
    const n = graph.length;
    const dist = Array(n).fill(null).map(() => Array(n).fill(Infinity));
    
    // 初始化
    for (let i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    
    // 填充直接边权重
    for (const [u, v, w] of graph) {
        dist[u][v] = w;
    }
    
    // Floyd-Warshall核心
    for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    
    return dist;
}

// 测试 (节点0,1,2,3)
const graph = [
    [0, 3, Infinity, 7],
    [8, 0, 2, Infinity],
    [5, Infinity, 0, 1],
    [2, Infinity, Infinity, 0]
];
console.log(floydWarshall(graph));
                            </code></pre></div>
                    </div>
                    <div id="floyd-python" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-python">
def floyd_warshall(graph):
    n = len(graph)
    dist = [[float('inf')] * n for _ in range(n)]
    
    for i in range(n):
        dist[i][i] = 0
    
    for u, v, w in graph:
        dist[u][v] = w
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

# 测试 (节点0,1,2,3)
graph = [
    [0, 3, float('inf'), 7],
    [8, 0, 2, float('inf')],
    [5, float('inf'), 0, 1],
    [2, float('inf'), float('inf'), 0]
]
print(floyd_warshall(graph))
                            </code></pre></div>
                    </div>
                    <div id="floyd-go" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-go">
package main

import (
    "fmt"
    "math"
)

func floydWarshall(graph [][]int) [][]int {
    n := len(graph)
    dist := make([][]int, n)
    const INF = 1 << 30
    
    for i := 0; i < n; i++ {
        dist[i] = make([]int, n)
        for j := 0; j < n; j++ {
            if i == j {
                dist[i][j] = 0
            } else {
                dist[i][j] = INF
            }
        }
    }
    
    for _, edge := range graph {
        u, v, w := edge[0], edge[1], edge[2]
        dist[u][v] = w
    }
    
    for k := 0; k < n; k++ {
        for i := 0; i < n; i++ {
            for j := 0; j < n; j++ {
                if dist[i][k]+dist[k][j] < dist[i][j] {
                    dist[i][j] = dist[i][k] + dist[k][j]
                }
            }
        }
    }
    
    return dist
}

func main() {
    graph := [][]int{
        {0, 3, 0, 7},
        {8, 0, 2, 0},
        {5, 0, 0, 1},
        {2, 0, 0, 0},
    }
    result := floydWarshall(graph)
    fmt.Println(result)
}
                            </code></pre></div>
                    </div>
                </div>
            </div>

            <h3>最小生成树 (Prim算法)</h3>
            <div class="algorithm-content">
                <p>在一个带权连通图中找到一棵包含所有顶点的树，且树中所有边的权重之和最小。</p>
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="prim-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="prim-python">Python</button>
                        <button class="code-tab-btn" data-tab="prim-go">Go</button>
                    </div>
                    <div id="prim-js" class="code-tab-content active">
                        <div class="code-block line-numbers"><pre><code class="language-javascript">
function prim(graph) {
    const n = graph.length;
    const key = Array(n).fill(Infinity);
    const parent = Array(n).fill(-1);
    const mst = new Set();
    
    key[0] = 0;
    
    for (let i = 0; i < n - 1; i++) {
        // 找到key值最小的顶点
        let u = -1;
        for (let v = 0; v < n; v++) {
            if (!mst.has(v) && (u === -1 || key[v] < key[u])) {
                u = v;
            }
        }
        
        mst.add(u);
        
        // 更新相邻顶点的key值
        for (let v = 0; v < n; v++) {
            if (graph[u][v] && !mst.has(v) && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }
    
    return parent;
}

// 测试
const graph = [
    [0, 2, 0, 6, 0],
    [2, 0, 3, 8, 5],
    [0, 3, 0, 0, 7],
    [6, 8, 0, 0, 9],
    [0, 5, 7, 9, 0]
];
const mst = prim(graph);
console.log("最小生成树的边：");
for (let i = 1; i < mst.length; i++) {
    console.log(`${mst[i]} - ${i}`);
}
                            </code></pre></div>
                    </div>
                    <div id="prim-python" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-python">
def prim(graph):
    n = len(graph)
    key = [float('inf')] * n
    parent = [-1] * n
    mst = set()
    
    key[0] = 0
    
    for _ in range(n - 1):
        u = -1
        for v in range(n):
            if v not in mst and (u == -1 or key[v] < key[u]):
                u = v
        
        mst.add(u)
        
        for v in range(n):
            if graph[u][v] and v not in mst and graph[u][v] < key[v]:
                parent[v] = u
                key[v] = graph[u][v]
    
    return parent

# 测试
graph = [
    [0, 2, 0, 6, 0],
    [2, 0, 3, 8, 5],
    [0, 3, 0, 0, 7],
    [6, 8, 0, 0, 9],
    [0, 5, 7, 9, 0]
]
mst = prim(graph)
print("最小生成树的边：")
for i in range(1, len(mst)):
    print(f"{mst[i]} - {i}")
                            </code></pre></div>
                    </div>
                    <div id="prim-go" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-go">
package main

import (
    "fmt"
    "math"
)

func prim(graph [][]int) []int {
    n := len(graph)
    key := make([]int, n)
    parent := make([]int, n)
    mst := make([]bool, n)
    const INF = 1 << 30
    
    for i := 0; i < n; i++ {
        key[i] = INF
        parent[i] = -1
    }
    
    key[0] = 0
    
    for i := 0; i < n-1; i++ {
        u := -1
        for v := 0; v < n; v++ {
            if !mst[v] && (u == -1 || key[v] < key[u]) {
                u = v
            }
        }
        
        mst[u] = true
        
        for v := 0; v < n; v++ {
            if graph[u][v] != 0 && !mst[v] && graph[u][v] < key[v] {
                parent[v] = u
                key[v] = graph[u][v]
            }
        }
    }
    
    return parent
}

func main() {
    graph := [][]int{
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0},
    }
    mst := prim(graph)
    fmt.Println("最小生成树的边：")
    for i := 1; i < len(mst); i++ {
        fmt.Printf("%d - %d\n", mst[i], i)
    }
}
                            </code></pre></div>
                    </div>
                </div>
            </div>

            <h3>拓扑排序</h3>
            <div class="algorithm-content">
                <p>对有向无环图(DAG)的顶点进行排序，使得对于每一条有向边(u, v)，u都在v之前。</p>
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="topo-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="topo-python">Python</button>
                        <button class="code-tab-btn" data-tab="topo-go">Go</button>
                    </div>
                    <div id="topo-js" class="code-tab-content active">
                        <div class="code-block line-numbers"><pre><code class="language-javascript">
function topologicalSort(graph) {
    const inDegree = {};
    const queue = [];
    const result = [];
    
    // 初始化入度
    for (const node in graph) {
        inDegree[node] = 0;
    }
    for (const node in graph) {
        for (const neighbor of graph[node]) {
            inDegree[neighbor]++;
        }
    }
    
    // 将入度为0的节点加入队列
    for (const node in inDegree) {
        if (inDegree[node] === 0) {
            queue.push(node);
        }
    }
    
    // BFS处理
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);
        
        for (const neighbor of graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] === 0) {
                queue.push(neighbor);
            }
        }
    }
    
    return result.length === Object.keys(graph).length ? result : [];
}

// 测试
const courseGraph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
};
console.log(topologicalSort(courseGraph)); // ['B', 'A', 'D', 'C', 'E', 'F']
                            </code></pre></div>
                    </div>
                    <div id="topo-python" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-python">
from collections import deque

def topological_sort(graph):
    in_degree = {node: 0 for node in graph}
    
    for node in graph:
        for neighbor in graph[node]:
            in_degree[neighbor] += 1
    
    queue = deque([node for node in in_degree if in_degree[node] == 0])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return result if len(result) == len(graph) else []

# 测试
course_graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
}
print(topological_sort(course_graph))  # ['B', 'A', 'D', 'C', 'E', 'F']
                            </code></pre></div>
                    </div>
                    <div id="topo-go" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-go">
package main

import (
    "fmt"
)

func topologicalSort(graph map[string][]string) []string {
    inDegree := make(map[string]int)
    
    for node := range graph {
        inDegree[node] = 0
    }
    
    for node, neighbors := range graph {
        for _, neighbor := range neighbors {
            inDegree[neighbor]++
        }
    }
    
    var queue []string
    for node, degree := range inDegree {
        if degree == 0 {
            queue = append(queue, node)
        }
    }
    
    var result []string
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        result = append(result, node)
        
        for _, neighbor := range graph[node] {
            inDegree[neighbor]--
            if inDegree[neighbor] == 0 {
                queue = append(queue, neighbor)
            }
        }
    }
    
    if len(result) == len(graph) {
        return result
    }
    return nil
}

func main() {
    courseGraph := map[string][]string{
        "A": {"C"},
        "B": {"C", "D"},
        "C": {"E"},
        "D": {"F"},
        "E": {"F"},
        "F": {},
    }
    fmt.Println(topologicalSort(courseGraph))  // [B A D C E F]
}
                            </code></pre></div>
                    </div>
                </div>
            </div>

            <h3>最大流算法 (Max Flow)</h3>
            <div class="algorithm-content">
                <h3>什么是最大流问题？</h3>
                <p>最大流问题旨在找出从源点(source)到汇点(sink)的最大流量，使得每条边的流量不超过其容量，且满足流量守恒定律。</p>
                
                <p style="margin-top: 15px;"><strong>基本概念：</strong></p>
                <ul style="margin-left: 20px;">
                    <li><strong>容量(Capacity)：</strong>边的最大允许流量</li>
                    <li><strong>流量(Flow)：</strong>实际通过边的流量</li>
                    <li><strong>残量网络(Residual Network)：</strong>表示剩余可用容量的网络</li>
                    <li><strong>增广路径(Augmenting Path)：</strong>残量网络中从源点到汇点的路径</li>
                </ul>

                <p style="margin-top: 15px;"><strong>Ford-Fulkerson方法：</strong></p>
                <ol style="margin-left: 20px;">
                    <li>初始化流为0</li>
                    <li>在残量网络中寻找增广路径</li>
                    <li>沿增广路径增加流量</li>
                    <li>重复直到没有增广路径</li>
                </ol>
            </div>

            <div class="code-tabs">
                <div class="code-tab-header">
                    <button class="code-tab-btn active" data-tab="ford-fulkerson-js">JavaScript</button>
                    <button class="code-tab-btn" data-tab="ford-fulkerson-python">Python</button>
                </div>
                <div id="ford-fulkerson-js" class="code-tab-content active">
                    <div class="code-block line-numbers"><pre><code class="language-javascript">
class MaxFlow {
    constructor(n) {
        this.n = n;
        this.graph = Array(n).fill(null).map(() => Array(n).fill(0));
    }

    addEdge(u, v, capacity) {
        this.graph[u][v] = capacity;
    }

    bfs(s, t, parent) {
        const visited = new Array(this.n).fill(false);
        const queue = [s];
        visited[s] = true;
        parent[s] = -1;

        while (queue.length > 0) {
            const u = queue.shift();

            for (let v = 0; v < this.n; v++) {
                if (!visited[v] && this.graph[u][v] > 0) {
                    visited[v] = true;
                    parent[v] = u;
                    queue.push(v);
                    if (v === t) return true;
                }
            }
        }
        return false;
    }

    fordFulkerson(s, t) {
        const parent = new Array(this.n).fill(-1);
        let maxFlow = 0;

        while (this.bfs(s, t, parent)) {
            let pathFlow = Infinity;
            for (let v = t; v !== s; v = parent[v]) {
                const u = parent[v];
                pathFlow = Math.min(pathFlow, this.graph[u][v]);
            }

            for (let v = t; v !== s; v = parent[v]) {
                const u = parent[v];
                this.graph[u][v] -= pathFlow;
                this.graph[v][u] += pathFlow;
            }

            maxFlow += pathFlow;
        }
        return maxFlow;
    }
}

// 测试：经典的"最大流最小割"示例
const maxFlow = new MaxFlow(6);
maxFlow.addEdge(0, 1, 16);
maxFlow.addEdge(0, 2, 13);
maxFlow.addEdge(1, 2, 10);
maxFlow.addEdge(1, 3, 12);
maxFlow.addEdge(2, 1, 4);
maxFlow.addEdge(2, 4, 14);
maxFlow.addEdge(3, 2, 9);
maxFlow.addEdge(3, 5, 20);
maxFlow.addEdge(4, 3, 7);
maxFlow.addEdge(4, 5, 4);

console.log("最大流量:", maxFlow.fordFulkerson(0, 5)); // 23
                    </code></pre></div>
                </div>
                <div id="ford-fulkerson-python" class="code-tab-content">
                    <div class="code-block line-numbers"><pre><code class="language-python">
class MaxFlow:
    def __init__(self, n):
        self.n = n
        self.graph = [[0] * n for _ in range(n)]

    def add_edge(self, u, v, capacity):
        self.graph[u][v] = capacity

    def bfs(self, s, t, parent):
        visited = [False] * self.n
        queue = [s]
        visited[s] = True
        parent[s] = -1

        while queue:
            u = queue.pop(0)
            for v in range(self.n):
                if not visited[v] and self.graph[u][v] > 0:
                    visited[v] = True
                    parent[v] = u
                    queue.append(v)
                    if v == t:
                        return True
        return False

    def ford_fulkerson(self, s, t):
        parent = [-1] * self.n
        max_flow = 0

        while self.bfs(s, t, parent):
            path_flow = float('inf')
            v = t
            while v != s:
                u = parent[v]
                path_flow = min(path_flow, self.graph[u][v])
                v = u

            v = t
            while v != s:
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = u

            max_flow += path_flow

        return max_flow

# 测试
max_flow = MaxFlow(6)
max_flow.add_edge(0, 1, 16)
max_flow.add_edge(0, 2, 13)
max_flow.add_edge(1, 2, 10)
max_flow.add_edge(1, 3, 12)
max_flow.add_edge(2, 1, 4)
max_flow.add_edge(2, 4, 14)
max_flow.add_edge(3, 2, 9)
max_flow.add_edge(3, 5, 20)
max_flow.add_edge(4, 3, 7)
max_flow.add_edge(4, 5, 4)

print("最大流量:", max_flow.ford_fulkerson(0, 5))  # 23
                    </code></pre></div>
                </div>
            </div>

            <h3>Dinic算法（更高效的最大流）</h3>
            <div class="algorithm-content">
                <p>Dinic算法通过构建分层图和使用DFS寻找阻塞流，在稀疏图上时间复杂度为O(V²E)。</p>
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="dinic-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="dinic-python">Python</button>
                    </div>
                    <div id="dinic-js" class="code-tab-content active">
                        <div class="code-block line-numbers"><pre><code class="language-javascript">
class Dinic {
    constructor(n) {
        this.n = n;
        this.adj = Array(n).fill(null).map(() => []);
    }

    addEdge(u, v, capacity) {
        this.adj[u].push({ to: v, cap: capacity, rev: this.adj[v].length });
        this.adj[v].push({ to: u, cap: 0, rev: this.adj[u].length - 1 });
    }

    bfs(s, t, level) {
        level.fill(-1);
        level[s] = 0;
        const queue = [s];

        while (queue.length > 0) {
            const u = queue.shift();
            for (const edge of this.adj[u]) {
                if (edge.cap > 0 && level[edge.to] < 0) {
                    level[edge.to] = level[u] + 1;
                    queue.push(edge.to);
                }
            }
        }
        return level[t] >= 0;
    }

    dfs(u, t, f, level, it) {
        if (u === t) return f;

        for (let i = it[u]; i < this.adj[u].length; i++) {
            const edge = this.adj[u][i];
            if (edge.cap > 0 && level[u] + 1 === level[edge.to]) {
                const ret = this.dfs(edge.to, t, Math.min(f, edge.cap), level, it);
                if (ret > 0) {
                    edge.cap -= ret;
                    this.adj[edge.to][edge.rev].cap += ret;
                    return ret;
                }
            }
            it[u]++;
        }
        return 0;
    }

    maxFlow(s, t) {
        const level = new Array(this.n).fill(-1);
        let flow = 0;
        const INF = 1 << 30;

        while (this.bfs(s, t, level)) {
            const it = new Array(this.n).fill(0);
            while (true) {
                const f = this.dfs(s, t, INF, level, it);
                if (f === 0) break;
                flow += f;
            }
        }
        return flow;
    }
}

// 测试
const dinic = new Dinic(6);
dinic.addEdge(0, 1, 16);
dinic.addEdge(0, 2, 13);
dinic.addEdge(1, 2, 10);
dinic.addEdge(1, 3, 12);
dinic.addEdge(2, 1, 4);
dinic.addEdge(2, 4, 14);
dinic.addEdge(3, 2, 9);
dinic.addEdge(3, 5, 20);
dinic.addEdge(4, 3, 7);
dinic.addEdge(4, 5, 4);

console.log("Dinic最大流量:", dinic.maxFlow(0, 5)); // 23
                    </code></pre></div>
                    </div>
                    <div id="dinic-python" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-python">
from collections import deque

class Dinic:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n)]

    def add_edge(self, u, v, capacity):
        self.adj[u].append([v, capacity, len(self.adj[v])])
        self.adj[v].append([u, 0, len(self.adj[u]) - 1])

    def bfs(self, s, t, level):
        level[:] = [-1] * self.n
        level[s] = 0
        queue = deque([s])

        while queue:
            u = queue.popleft()
            for v, cap, _ in self.adj[u]:
                if cap > 0 and level[v] < 0:
                    level[v] = level[u] + 1
                    queue.append(v)
        return level[t] >= 0

    def dfs(self, u, t, f, level, it):
        if u == t:
            return f
        for i in range(it[u], len(self.adj[u])):
            it[u] = i
            v, cap, rev = self.adj[u][i]
            if cap > 0 and level[u] + 1 == level[v]:
                ret = self.dfs(v, t, min(f, cap), level, it)
                if ret:
                    self.adj[u][i][1] -= ret
                    self.adj[v][rev][1] += ret
                    return ret
        return 0

    def max_flow(self, s, t):
        level = [-1] * self.n
        flow = 0
        INF = 10 ** 18

        while self.bfs(s, t, level):
            it = [0] * self.n
            while True:
                f = self.dfs(s, t, INF, level, it)
                if not f:
                    break
                flow += f
        return flow

# 测试
dinic = Dinic(6)
dinic.add_edge(0, 1, 16)
dinic.add_edge(0, 2, 13)
dinic.add_edge(1, 2, 10)
dinic.add_edge(1, 3, 12)
dinic.add_edge(2, 1, 4)
dinic.add_edge(2, 4, 14)
dinic.add_edge(3, 2, 9)
dinic.add_edge(3, 5, 20)
dinic.add_edge(4, 3, 7)
dinic.add_edge(4, 5, 4)

print("Dinic最大流量:", dinic.max_flow(0, 5))  # 23
                    </code></pre></div>
                    </div>
                </div>
            </div>

            <h3>最小割 (Min Cut)</h3>
            <div class="algorithm-content">
                <h3>最大流最小割定理</h3>
                <p><strong>定理：</strong>在任何网络中，最大流的值等于最小割的容量。</p>
                <p style="margin-top: 15px;"><strong>最小割定义：</strong></p>
                <p>将网络中的顶点分成两个不相交的集合S和T，使得源点在S中，汇点在T中，且跨越S和T的边容量之和最小。</p>
                <p style="margin-top: 15px;"><strong>求最小割方法：</strong></p>
                <ol style="margin-left: 20px;">
                    <li>运行最大流算法</li>
                    <li>在最终残量网络中，从源点出发沿残量边可达的顶点构成集合S</li>
                    <li>跨越S和T的边即为最小割</li>
                </ol>
            </div>

            <h3>Stoer-Wagner全局最小割算法</h3>
            <div class="algorithm-content">
                <p>求无向图中任意两点之间的最小割，时间复杂度O(V³)。</p>
                <div class="code-tabs">
                    <div class="code-tab-header">
                        <button class="code-tab-btn active" data-tab="stoer-js">JavaScript</button>
                        <button class="code-tab-btn" data-tab="stoer-python">Python</button>
                    </div>
                    <div id="stoer-js" class="code-tab-content active">
                        <div class="code-block line-numbers"><pre><code class="language-javascript">
class StoerWagner {
    constructor(n) {
        this.n = n;
        this.graph = Array(n).fill(null).map(() => Array(n).fill(0));
    }

    addEdge(u, v, weight) {
        this.graph[u][v] += weight;
        this.graph[v][u] += weight;
    }

    minCut() {
        const vertices = Array.from({ length: this.n }, (_, i) => i);
        let minCut = Infinity;

        while (vertices.length > 1) {
            const weights = new Array(this.n).fill(0);
            const added = new Array(this.n).fill(false);
            let prev = -1;

            // 最大权重搜索（类似Prim）
            for (let i = 0; i < vertices.length; i++) {
                let maxWeight = -1;
                let maxIdx = -1;

                for (const v of vertices) {
                    if (!added[v] && weights[v] > maxWeight) {
                        maxWeight = weights[v];
                        maxIdx = v;
                    }
                }

                added[maxIdx] = true;

                if (i === vertices.length - 1) {
                    // 最后加入的顶点s和t
                    const s = prev;
                    const t = maxIdx;
                    minCut = Math.min(minCut, maxWeight);

                    // 合并s和t
                    for (let v = 0; v < this.n; v++) {
                        this.graph[s][v] += this.graph[t][v];
                        this.graph[v][s] += this.graph[t][v];
                    }

                    vertices.splice(vertices.indexOf(t), 1);
                    break;
                }

                prev = maxIdx;

                for (const v of vertices) {
                    if (!added[v]) {
                        weights[v] += this.graph[maxIdx][v];
                    }
                }
            }
        }

        return minCut;
    }
}

// 测试：求图的全局最小割
const sw = new StoerWagner(4);
sw.addEdge(0, 1, 6);
sw.addEdge(0, 2, 5);
sw.addEdge(0, 3, 4);
sw.addEdge(1, 2, 3);
sw.addEdge(1, 3, 2);
sw.addEdge(2, 3, 3);

console.log("全局最小割:", sw.minCut());
                    </code></pre></div>
                    <div id="stoer-python" class="code-tab-content">
                        <div class="code-block line-numbers"><pre><code class="language-python">
class StoerWagner:
    def __init__(self, n):
        self.n = n
        self.graph = [[0] * n for _ in range(n)]

    def add_edge(self, u, v, weight):
        self.graph[u][v] += weight
        self.graph[v][u] += weight

    def min_cut(self):
        vertices = list(range(self.n))
        min_cut = float('inf')

        while len(vertices) > 1:
            weights = [0] * self.n
            added = [False] * self.n
            prev = -1

            for i in range(len(vertices)):
                max_weight = -1
                max_idx = -1

                for v in vertices:
                    if not added[v] and weights[v] > max_weight:
                        max_weight = weights[v]
                        max_idx = v

                added[max_idx] = True

                if i == len(vertices) - 1:
                    s = prev
                    t = max_idx
                    min_cut = min(min_cut, max_weight)

                    # 合并s和t
                    for v in range(self.n):
                        self.graph[s][v] += self.graph[t][v]
                        self.graph[v][s] += self.graph[t][v]

                    vertices.remove(t)
                    break

                prev = max_idx

                for v in vertices:
                    if not added[v]:
                        weights[v] += self.graph[max_idx][v]

        return min_cut

# 测试
sw = StoerWagner(4)
sw.add_edge(0, 1, 6)
sw.add_edge(0, 2, 5)
sw.add_edge(0, 3, 4)
sw.add_edge(1, 2, 3)
sw.add_edge(1, 3, 2)
sw.add_edge(2, 3, 3)

print("全局最小割:", sw.min_cut())
                    </code></pre></div>
                </div>
            </div>

            <h3>二分图最大匹配 (Hopcroft-Karp)</h3>
            <div class="algorithm-content">
                <p>在二分图中找到最大数量的匹配边，使得没有两条边共享同一个顶点。Hopcroft-Karp算法时间复杂度为O(E√V)。</p>
            </div>

            <h3>最小生成树 (MST)</h3>
            <div class="algorithm-content">
                <h3>什么是最小生成树？</h3>
                <p>最小生成树（Minimum Spanning Tree）是在一个连通加权无向图中找到一个包含所有顶点的树，且树中所有边的权重之和最小。</p>
                
                <p style="margin-top: 15px;"><strong>基本性质：</strong></p>
                <ul style="margin-left: 20px;">
                    <li><strong>切割性质：</strong>横跨任何切割的边中，权重最小的边一定属于某个MST</li>
                    <li><strong>回路性质：</strong>在回路中，权重最大的边一定不属于任何MST</li>
                </ul>
            </div>

            <div class="complexity">
                <div class="complexity-item">
                    <h4>Kruskal</h4>
                    <p>O(E log E)</p>
                </div>
                <div class="complexity-item">
                    <h4>Prim</h4>
                    <p>O(E log V)</p>
                </div>
            </div>

            <h3>Kruskal算法</h3>
            <div class="algorithm-content">
                <p><strong>算法思想：</strong>按照边权重从小到大排序，依次添加边，如果添加的边不形成回路，则将其加入生成树。</p>
                
                <p style="margin-top: 15px;"><strong>使用并查集(Union-Find)检测回路：</strong></p>
                <ul style="margin-left: 20px;">
                    <li><strong>Find：</strong>查找元素所属的集合（根节点）</li>
                    <li><strong>Union：</strong>合并两个集合</li>
                    <li><strong>路径压缩：</strong>加速Find操作</li>
                </ul>
            </div>

            <div class="code-tabs">
                <div class="code-tab-header">
                    <button class="code-tab-btn active" data-tab="kruskal-js">JavaScript</button>
                    <button class="code-tab-btn" data-tab="kruskal-python">Python</button>
                </div>
                <div id="kruskal-js" class="code-tab-content active">
                    <div class="code-block line-numbers"><pre><code class="language-javascript">
class UnionFind {
    constructor(n) {
        this.parent = Array(n).fill(0).map((_, i) => i);
        this.rank = Array(n).fill(0);
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]); // 路径压缩
        }
        return this.parent[x];
    }

    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        // 按秩合并
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }
        return true;
    }
}

class Kruskal {
    constructor(n) {
        this.n = n;
        this.edges = [];
    }

    addEdge(u, v, w) {
        this.edges.push({ u, v, w });
    }

    mst() {
        // 按权重排序
        this.edges.sort((a, b) => a.w - b.w);
        
        const uf = new UnionFind(this.n);
        const mst = [];
        let totalWeight = 0;
        
        for (const edge of this.edges) {
            if (uf.union(edge.u, edge.v)) {
                mst.push(edge);
                totalWeight += edge.w;
            }
        }
        
        return { edges: mst, totalWeight };
    }
}

// 测试
const kruskal = new Kruskal(5);
kruskal.addEdge(0, 1, 2);
kruskal.addEdge(0, 3, 6);
kruskal.addEdge(1, 2, 3);
kruskal.addEdge(1, 3, 8);
kruskal.addEdge(1, 4, 5);
kruskal.addEdge(2, 4, 7);
kruskal.addEdge(3, 4, 9);

const result = kruskal.mst();
console.log("MST总权重:", result.totalWeight);
console.log("MST边:", result.edges);
                    </code></pre></div>
                </div>
                <div id="kruskal-python" class="code-tab-content">
                    <div class="code-block line-numbers"><pre><code class="language-python">
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        return True

class Kruskal:
    def __init__(self, n):
        self.n = n
        self.edges = []
    
    def add_edge(self, u, v, w):
        self.edges.append((u, v, w))
    
    def mst(self):
        self.edges.sort(key=lambda x: x[2])
        
        uf = UnionFind(self.n)
        mst = []
        total_weight = 0
        
        for u, v, w in self.edges:
            if uf.union(u, v):
                mst.append((u, v, w))
                total_weight += w
        
        return mst, total_weight

# 测试
kruskal = Kruskal(5)
kruskal.add_edge(0, 1, 2)
kruskal.add_edge(0, 3, 6)
kruskal.add_edge(1, 2, 3)
kruskal.add_edge(1, 3, 8)
kruskal.add_edge(1, 4, 5)
kruskal.add_edge(2, 4, 7)
kruskal.add_edge(3, 4, 9)

mst, weight = kruskal.mst()
print("MST总权重:", weight)
print("MST边:", mst)
                    </code></pre></div>
                </div>
            </div>

            <h3>Prim算法</h3>
            <div class="algorithm-content">
                <p><strong>算法思想：</strong>从任意一个顶点开始，逐步扩展生成树。每次选择一条连接已选顶点集合和未选顶点集合的最小权重边。</p>
                
                <p style="margin-top: 15px;"><strong>实现方式：</strong></p>
                <ul style="margin-left: 20px;">
                    <li><strong>朴素版：</strong>O(V²)，适合稠密图</li>
                    <li><strong>优先队列版：</strong>O(E log V)，适合稀疏图</li>
                </ul>
            </div>

            <div class="code-tabs">
                <div class="code-tab-header">
                    <button class="code-tab-btn active" data-tab="prim-js">JavaScript</button>
                    <button class="code-tab-btn" data-tab="prim-python">Python</button>
                </div>
                <div id="prim-js" class="code-tab-content active">
                    <div class="code-block line-numbers"><pre><code class="language-javascript">
class Prim {
    constructor(n) {
        this.n = n;
        this.graph = Array(n).fill(null).map(() => Array(n).fill(0));
    }

    addEdge(u, v, w) {
        this.graph[u][v] = w;
        this.graph[v][u] = w;
    }

    mst(start = 0) {
        const key = Array(this.n).fill(Infinity);
        const parent = Array(this.n).fill(-1);
        const inMST = Array(this.n).fill(false);
        const pq = new PriorityQueue();

        key[start] = 0;
        pq.enqueue(start, 0);

        while (!pq.isEmpty()) {
            const { element: u } = pq.dequeue();
            inMST[u] = true;

            for (let v = 0; v < this.n; v++) {
                if (this.graph[u][v] > 0 && !inMST[v] && this.graph[u][v] < key[v]) {
                    key[v] = this.graph[u][v];
                    parent[v] = u;
                    pq.enqueue(v, key[v]);
                }
            }
        }

        const mst = [];
        let totalWeight = 0;
        for (let i = 1; i < this.n; i++) {
            if (parent[i] !== -1) {
                mst.push({ u: parent[i], v: i, w: this.graph[parent[i]][i] });
                totalWeight += this.graph[parent[i]][i];
            }
        }

        return { edges: mst, totalWeight };
    }
}

class PriorityQueue {
    constructor() {
        this.items = [];
    }

    enqueue(element, priority) {
        this.items.push({ element, priority });
        this.items.sort((a, b) => a.priority - b.priority);
    }

    dequeue() {
        return this.items.shift();
    }

    isEmpty() {
        return this.items.length === 0;
    }
}

// 测试
const prim = new Prim(5);
prim.addEdge(0, 1, 2);
prim.addEdge(0, 3, 6);
prim.addEdge(1, 2, 3);
prim.addEdge(1, 3, 8);
prim.addEdge(1, 4, 5);
prim.addEdge(2, 4, 7);
prim.addEdge(3, 4, 9);

const result2 = prim.mst(0);
console.log("MST总权重:", result2.totalWeight);
console.log("MST边:", result2.edges);
                    </code></pre></div>
                </div>
                <div id="prim-python" class="code-tab-content">
                    <div class="code-block line-numbers"><pre><code class="language-python">
import heapq

class Prim:
    def __init__(self, n):
        self.n = n
        self.graph = [[0] * n for _ in range(n)]
    
    def add_edge(self, u, v, w):
        self.graph[u][v] = w
        self.graph[v][u] = w
    
    def mst(self, start=0):
        key = [float('inf')] * self.n
        parent = [-1] * self.n
        in_mst = [False] * self.n
        
        key[start] = 0
        pq = [(0, start)]  # (weight, vertex)
        
        while pq:
            weight, u = heapq.heappop(pq)
            if in_mst[u]:
                continue
            in_mst[u] = True
            
            for v in range(self.n):
                if self.graph[u][v] > 0 and not in_mst[v]:
                    if self.graph[u][v] < key[v]:
                        key[v] = self.graph[u][v]
                        parent[v] = u
                        heapq.heappush(pq, (key[v], v))
        
        mst = []
        total_weight = 0
        for i in range(1, self.n):
            if parent[i] != -1:
                mst.append((parent[i], i, self.graph[parent[i]][i]))
                total_weight += self.graph[parent[i]][i]
        
        return mst, total_weight

# 测试
prim = Prim(5)
prim.add_edge(0, 1, 2)
prim.add_edge(0, 3, 6)
prim.add_edge(1, 2, 3)
prim.add_edge(1, 3, 8)
prim.add_edge(1, 4, 5)
prim.add_edge(2, 4, 7)
prim.add_edge(3, 4, 9)

mst, weight = prim.mst(0)
print("MST总权重:", weight)
print("MST边:", mst)
                    </code></pre></div>
                </div>
            </div>

            <h3>Kruskal vs Prim</h3>
            <div class="algorithm-content">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #3498db; color: white;">
                        <th style="padding: 12px;">特性</th>
                        <th style="padding: 12px;">Kruskal</th>
                        <th style="padding: 12px;">Prim</th>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px;">时间复杂度</td>
                        <td style="padding: 12px;">O(E log E)</td>
                        <td style="padding: 12px;">O(E log V)</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px;">适用图类型</td>
                        <td style="padding: 12px;">稀疏图</td>
                        <td style="padding: 12px;">稠密图</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px;">实现复杂度</td>
                        <td style="padding: 12px;">简单</td>
                        <td style="padding: 12px;">中等</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px;">数据结构</td>
                        <td style="padding: 12px;">并查集</td>
                        <td style="padding: 12px;">优先队列</td>
                    </tr>
                </table>
            </div>

            <h3>最小生成树应用场景</h3>
            <div class="algorithm-content">
                <ul>
                    <li><strong>网络设计：</strong>通信网络、电网的最小成本建设</li>
                    <li><strong>聚类分析：</strong>基于MST的层次聚类</li>
                    <li><strong>图像处理：</strong>最小生成树用于图像分割</li>
                    <li><strong>近似算法：</strong>旅行商问题的近似解</li>
                </ul>
            </div>

            <h3>社区发现算法 (Community Detection)</h3>
            <div class="algorithm-content">
                <h3>什么是社区发现？</h3>
                <p>社区发现旨在将复杂网络中的节点分组，使得同一社区内的节点连接紧密，不同社区间的节点连接稀疏。这对于分析社交网络、生物网络等非常重要。</p>
                
                <p style="margin-top: 15px;"><strong>核心概念：</strong></p>
                <ul style="margin-left: 20px;">
                    <li><strong>社区(Community)：</strong>内部连接紧密的节点集合</li>
                    <li><strong>模块度(Modularity)：</strong>衡量社区划分质量的指标</li>
                    <li><strong>Q值：</strong>模块度的取值范围通常为[-0.5, 1]</li>
                </ul>
            </div>

            <div class="complexity">
                <div class="complexity-item">
                    <h4>Louvain</h4>
                    <p>O(n log n)</p>
                </div>
                <div class="complexity-item">
                    <h4>Girvan-Newman</h4>
                    <p>O(VE²)</p>
                </div>
            </div>

            <h3>Louvain算法</h3>
            <div class="algorithm-content">
                <p>Louvain算法是一种基于模块度优化的社区发现算法，时间复杂度接近线性，适合大规模网络。</p>
                
                <p style="margin-top: 15px;"><strong>算法步骤：</strong></p>
                <ol style="margin-left: 20px;">
                    <li><strong>初始阶段：</strong>每个节点作为一个独立的社区</li>
                    <li><strong>局部优化：</strong>将节点移动到能最大增加模块度的邻居社区</li>
                    <li><strong>凝聚阶段：</strong>将同一社区的节点合并为一个超节点</li>
                    <li><strong>迭代：</strong>重复步骤2-3直到模块度不再增加</li>
                </ol>

                <p style="margin-top: 15px;"><strong>模块度计算公式：</strong></p>
                <div style="background: #2d2d2d; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Consolas', monospace; color: #f8f8f2;">
                    <p>Q = (1/2m) × Σᵢⱼ [Aᵢⱼ - kᵢkⱼ/(2m)] × δ(cᵢ, cⱼ)</p>
                    <p>其中：</p>
                    <p>m = 边的总数</p>
                    <p>Aᵢⱼ = 邻接矩阵（1表示有边）</p>
                    <p>kᵢ = 节点i的度</p>
                    <p>cᵢ = 节点i所属社区</p>
                    <p>δ(cᵢ, cⱼ) = 1如果cᵢ = cⱼ，否则为0</p>
                </div>
            </div>

            <div class="code-tabs">
                <div class="code-tab-header">
                    <button class="code-tab-btn active" data-tab="louvain-js">JavaScript</button>
                    <button class="code-tab-btn" data-tab="louvain-python">Python</button>
                </div>
                <div id="louvain-js" class="code-tab-content active">
                    <div class="code-block line-numbers"><pre><code class="language-javascript">
class Louvain {
    constructor() {
        this.graph = new Map();
        this.communities = new Map();
        this.weights = new Map();
    }

    addEdge(u, v, weight = 1) {
        if (!this.graph.has(u)) {
            this.graph.set(u, new Map());
            this.communities.set(u, u);
        }
        if (!this.graph.has(v)) {
            this.graph.set(v, new Map());
            this.communities.set(v, v);
        }

        const key = u < v ? `${u}-${v}` : `${v}-${u}`;
        const existing = this.graph.get(u).get(v) || 0;
        this.graph.get(u).set(v, existing + weight);
        this.graph.get(v).set(u, existing + weight);
    }

    _getNeighbors(node) {
        return this.graph.get(node) || new Map();
    }

    _getWeight(u, v) {
        return this._getNeighbors(u).get(v) || 0;
    }

    _getDegree(node) {
        return Array.from(this._getNeighbors(node).values()).reduce((a, b) => a + b, 0);
    }

    _calculateModularity() {
        let Q = 0;
        const m = this._getTotalWeight();
        
        for (const [u, neighbors] of this.graph) {
            for, w] of (const [v neighbors) {
                if (u < v) {
                    const cu = this.communities.get(u);
                    const cv = this.communities.get(v);
                    if (cu === cv) {
                        const ki = this._getDegree(u);
                        const kj = this._getDegree(v);
                        Q += (w - (ki * kj) / (2 * m));
                    }
                }
            }
        }
        
        return Q / m;
    }

    _getTotalWeight() {
        let total = 0;
        for (const [u, neighbors] of this.graph) {
            for (const [v, w] of neighbors) {
                if (u < v) total += w;
            }
        }
        return total;
    }

    _calculateDeltaQ(node, newCommunity, oldCommunity) {
        const m = this._getTotalWeight();
        const k = this._getDegree(node);
        
        let sumIn = 0;  // 新社区内部边的权重和
        let sumTot = 0; // 新社区所有边的权重和
        
        for (const [neighbor, w] of this._getNeighbors(node)) {
            if (this.communities.get(neighbor) === newCommunity) {
                sumIn += w;
                sumTot += w;
            } else if (this.communities.get(neighbor) === oldCommunity) {
                sumTot += w;
            }
        }
        
        const sigmaTot = sumTot;
        const kiIn = sumIn;
        
        return (sigmaTot + k) / m - Math.pow(kiIn + k, 2) / (m * m) 
             - (sigmaTot - k) / m - Math.pow(kiIn, 2) / (m * m);
    }

    fit(maxIterations = 100) {
        let iteration = 0;
        let modularity = this._calculateModularity();
        
        while (iteration < maxIterations) {
            let changed = false;
            
            for (const node of this.graph.keys()) {
                const currentCommunity = this.communities.get(node);
                const neighbors = this._getNeighbors(node);
                
                let bestCommunity = currentCommunity;
                let bestDeltaQ = 0;
                
                for (const [neighbor] of neighbors) {
                    const neighborCommunity = this.communities.get(neighbor);
                    if (neighborCommunity !== currentCommunity) {
                        const deltaQ = this._calculateDeltaQ(node, neighborCommunity, currentCommunity);
                        if (deltaQ > bestDeltaQ) {
                            bestDeltaQ = deltaQ;
                            bestCommunity = neighborCommunity;
                        }
                    }
                }
                
                if (bestCommunity !== currentCommunity && bestDeltaQ > 0) {
                    this.communities.set(node, bestCommunity);
                    changed = true;
                }
            }
            
            const newModularity = this._calculateModularity();
            if (!changed || Math.abs(newModularity - modularity) < 1e-6) {
                break;
            }
            modularity = newModularity;
            iteration++;
        }
        
        return {
            communities: this.communities,
            modularity: this._calculateModularity()
        };
    }

    getCommunityLabels() {
        const labels = {};
        for (const [node, community] of this.communities) {
            labels[node] = community;
        }
        return labels;
    }
}

// 测试：Karate Club网络
const louvain = new Louvain();
// 构建一个示例网络
louvain.addEdge(0, 1, 4);
louvain.addEdge(0, 2, 3);
louvain.addEdge(0, 3, 3);
louvain.addEdge(1, 2, 2);
louvain.addEdge(1, 3, 3);
louvain.addEdge(2, 3, 2);
louvain.addEdge(2, 4, 1);
louvain.addEdge(3, 4, 1);
louvain.addEdge(4, 5, 2);
louvain.addEdge(4, 6, 1);
louvain.addEdge(5, 6, 3);

const result = louvain.fit();
console.log("社区划分:", result.communities);
console.log("模块度:", result.modularity);
console.log("标签:", louvain.getCommunityLabels());
                    </code></pre></div>
                </div>
                <div id="louvain-python" class="code-tab-content">
                    <div class="code-block line-numbers"><pre><code class="language-python">
import numpy as np

class Louvain:
    def __init__(self):
        self.graph = {}
        self.communities = {}
        self.weights = {}
    
    def add_edge(self, u, v, weight=1):
        if u not in self.graph:
            self.graph[u] = {}
            self.communities[u] = u
        if v not in self.graph:
            self.graph[v] = {}
            self.communities[v] = v
        
        self.graph[u][v] = self.graph[u].get(v, 0) + weight
        self.graph[v][u] = self.graph[v].get(u, 0) + weight
    
    def _get_neighbors(self, node):
        return self.graph.get(node, {})
    
    def _get_weight(self, u, v):
        return self._get_neighbors(u).get(v, 0)
    
    def _get_degree(self, node):
        return sum(self._get_neighbors(node).values())
    
    def _get_total_weight(self):
        total = 0
        for u in self.graph:
            for v in self.graph[u]:
                if u < v:
                    total += self.graph[u][v]
        return total
    
    def _calculate_modularity(self):
        m = self._get_total_weight()
        Q = 0
        
        for u in self.graph:
            for v in self.graph[u]:
                if u < v:
                    cu = self.communities[u]
                    cv = self.communities[v]
                    if cu == cv:
                        w = self.graph[u][v]
                        ki = self._get_degree(u)
                        kj = self._get_degree(v)
                        Q += w - (ki * kj) / (2 * m)
        
        return Q / m
    
    def _calculate_delta_q(self, node, new_community, old_community):
        m = self._get_total_weight()
        k = self._get_degree(node)
        
        sum_in = 0
        sum_tot = 0
        
        for neighbor, w in self._get_neighbors(node).items():
            comm = self.communities[neighbor]
            if comm == new_community:
                sum_in += w
                sum_tot += w
            elif comm == old_community:
                sum_tot += w
        
        sigma_tot = sum_tot
        ki_in = sum_in
        
        return ((sigma_tot + k) / m - (ki_in + k) ** 2 / (m * m)
                - (sigma_tot - k) / m - ki_in ** 2 / (m * m))
    
    def fit(self, max_iterations=100):
        modularity = self._calculate_modularity()
        
        for _ in range(max_iterations):
            changed = False
            
            for node in self.graph:
                current_comm = self.communities[node]
                neighbors = self._get_neighbors(node)
                
                best_comm = current_comm
                best_delta = 0
                
                for neighbor in neighbors:
                    neighbor_comm = self.communities[neighbor]
                    if neighbor_comm != current_comm:
                        delta = self._calculate_delta_q(node, neighbor_comm, current_comm)
                        if delta > best_delta:
                            best_delta = delta
                            best_comm = neighbor_comm
                
                if best_comm != current_comm and best_delta > 0:
                    self.communities[node] = best_comm
                    changed = True
            
            new_modularity = self._calculate_modularity()
            if not changed or abs(new_modularity - modularity) < 1e-6:
                break
            modularity = new_modularity
        
        return {
            'communities': self.communities,
            'modularity': self._calculate_modularity()
        }

# 测试
louvain = Louvain()
louvain.add_edge(0, 1, 4)
louvain.add_edge(0, 2, 3)
louvain.add_edge(0, 3, 3)
louvain.add_edge(1, 2, 2)
louvain.add_edge(1, 3, 3)
louvain.add_edge(2, 3, 2)
louvain.add_edge(2, 4, 1)
louvain.add_edge(3, 4, 1)
louvain.add_edge(4, 5, 2)
louvain.add_edge(4, 6, 1)
louvain.add_edge(5, 6, 3)

result = louvain.fit()
print("社区划分:", result['communities'])
print("模块度:", result['modularity'])
                    </code></pre></div>
                </div>
            </div>

            <h3>Girvan-Newman算法</h3>
            <div class="algorithm-content">
                <p>Girvan-Newman是一种基于边介数的社区发现算法，通过逐步移除介数最大的边来分割网络。</p>
                
                <p style="margin-top: 15px;"><strong>核心概念：</strong></p>
                <ul style="margin-left: 20px;">
                    <li><strong>边介数(Betweenness)：</strong>经过一条边的最短路径数量</li>
                    <li>介数高的边通常是连接不同社区的"桥梁"</li>
                </ul>

                <p style="margin-top: 15px;"><strong>算法步骤：</strong></p>
                <ol style="margin-left: 20px;">
                    <li>计算所有边的介数</li>
                    <li>移除介数最高的边</li>
                    <li>重新计算剩余边的介数</li>
                    <li>重复直到达到期望的社区数量</li>
                </ol>
            </div>

            <div class="code-tabs">
                <div class="code-tab-header">
                    <button class="code-tab-btn active" data-tab="gn-js">JavaScript</button>
                    <button class="code-tab-btn" data-tab="gn-python">Python</button>
                </div>
                <div id="gn-js" class="code-tab-content active">
                    <div class="code-block line-numbers"><pre><code class="language-javascript">
class GirvanNewman {
    constructor() {
        this.graph = new Map();
    }

    addEdge(u, v) {
        if (!this.graph.has(u)) this.graph.set(u, new Set());
        if (!this.graph.has(v)) this.graph.set(v, new Set());
        this.graph.get(u).add(v);
        this.graph.get(v).add(u);
    }

    _bfs(source) {
        const distances = new Map();
        const parents = new Map();
        const edgeCount = new Map();
        const queue = [source];
        
        distances.set(source, 0);
        for (const node of this.graph.keys()) {
            if (node !== source) distances.set(node, -1);
            parents.set(node, []);
            edgeCount.set(node, 1);
        }
        
        const visited = new Set([source]);
        
        while (queue.length > 0) {
            const u = queue.shift();
            for (const v of this.graph.get(u)) {
                if (!visited.has(v)) {
                    visited.add(v);
                    distances.set(v, distances.get(u) + 1);
                    queue.push(v);
                    parents.get(v).push(u);
                } else if (distances.get(v) === distances.get(u) + 1) {
                    parents.get(v).push(u);
                }
            }
        }
        
        const betweenness = new Map();
        for (const node of this.graph.keys()) {
            betweenness.set(node, 0);
        }
        
        const reversed = [...this.graph.keys()].reverse();
        for (const u of reversed) {
            for (const v of parents.get(u)) {
                const contribution = edgeCount.get(u) * (1 + betweenness.get(u)) / edgeCount.get(v);
                betweenness.set(v, betweenness.get(v) + contribution);
            }
        }
        
        const edgeBetweenness = new Map();
        for (const u of this.graph.keys()) {
            for (const v of this.graph.get(u)) {
                if (u < v) {
                    const key = `${u}-${v}`;
                    edgeBetweenness.set(key, (betweenness.get(u) + betweenness.get(v)) / 2);
                }
            }
        }
        
        return edgeBetweenness;
    }

    calculateAllBetweenness() {
        const totalBetweenness = new Map();
        
        for (const node of this.graph.keys()) {
            const eb = this._bfs(node);
            for (const [edge, value] of eb) {
                totalBetweenness.set(edge, (totalBetweenness.get(edge) || 0) + value);
            }
        }
        
        return totalBetweenness;
    }

    getCommunities(nCommunities) {
        const originalGraph = new Map();
        for (const [node, neighbors] of this.graph) {
            originalGraph.set(node, new Set(neighbors));
        }
        
        const communities = [];
        for (const node of originalGraph.keys()) {
            communities.push([node]);
        }
        
        while (communities.length > nCommunities) {
            const betweenness = this.calculateAllBetweenness();
            
            // 找到介数最高的边
            let maxEdge = null;
            let maxValue = -1;
            for (const [edge, value] of betweenness) {
                if (value > maxValue) {
                    maxValue = value;
                    maxEdge = edge;
                }
            }
            
            if (!maxEdge) break;
            
            // 移除该边
            const [u, v] = maxEdge.split('-');
            this.graph.get(u).delete(v);
            this.graph.get(v).delete(u);
            
            // 如果图不连通，分裂社区
            if (!this._isConnected()) {
                const components = this._getComponents();
                // 更新communities数组
                const newCommunities = [];
                const nodeToNewComm = new Map();
                
                for (let i = 0; i < communities.length; i++) {
                    const compNodes = new Set(components.map(c => c.has(i) ? i : null).filter(x => x !== null));
                }
            }
        }
        
        return communities;
    }

    _isConnected() {
        if (this.graph.size === 0) return true;
        
        const visited = new Set();
        const queue = [this.graph.keys().next().value];
        
        while (queue.length > 0) {
            const node = queue.shift();
            visited.add(node);
            
            for (const neighbor of this.graph.get(node)) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                }
            }
        }
        
        return visited.size === this.graph.size;
    }

    _getComponents() {
        const visited = new Set();
        const components = [];
        
        for (const node of this.graph.keys()) {
            if (!visited.has(node)) {
                const component = new Set();
                const queue = [node];
                
                while (queue.length > 0) {
                    const u = queue.shift();
                    if (visited.has(u)) continue;
                    visited.add(u);
                    component.add(u);
                    
                    for (const v of this.graph.get(u)) {
                        if (!visited.has(v)) {
                            queue.push(v);
                        }
                    }
                }
                
                components.push(component);
            }
        }
        
        return components;
    }
}
                    </code></pre></div>
                </div>
                <div id="gn-python" class="code-tab-content">
                    <div class="code-block line-numbers"><pre><code class="language-python">
from collections import deque

class GirvanNewman:
    def __init__(self):
        self.graph = {}
    
    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = set()
        if v not in self.graph:
            self.graph[v] = set()
        self.graph[u].add(v)
        self.graph[v].add(u)
    
    def _bfs(self, source):
        distances = {source: 0}
        parents = {node: [] for node in self.graph}
        edge_count = {node: 1 for node in self.graph}
        queue = deque([source])
        visited = {source}
        
        while queue:
            u = queue.popleft()
            for v in self.graph[u]:
                if v not in visited:
                    visited.add(v)
                    distances[v] = distances[u] + 1
                    queue.append(v)
                    parents[v].append(u)
                elif distances[v] == distances[u] + 1:
                    parents[v].append(u)
        
        betweenness = {node: 0 for node in self.graph}
        
        for node in reversed(list(self.graph.keys())):
            for v in parents[node]:
                contribution = edge_count[node] * (1 + betweenness[node]) / edge_count[v]
                betweenness[v] += contribution
        
        edge_betweenness = {}
        for u in self.graph:
            for v in self.graph[u]:
                if u < v:
                    edge_betweenness[(u, v)] = (betweenness[u] + betweenness[v]) / 2
        
        return edge_betweenness
    
    def calculate_all_betweenness(self):
        total_betweenness = {}
        for node in self.graph:
            eb = self._bfs(node)
            for edge, value in eb.items():
                total_betweenness[edge] = total_betweenness.get(edge, 0) + value
        return total_betweenness
    
    def get_communities(self, n_communities):
        communities = [[node] for node in self.graph.keys()]
        
        while len(communities) > n_communities:
            betweenness = self.calculate_all_betweenness()
            
            if not betweenness:
                break
            
            max_edge = max(betweenness.items(), key=lambda x: x[1])[0]
            u, v = max_edge
            
            # 移除边
            self.graph[u].remove(v)
            self.graph[v].remove(u)
            
            # 检查是否形成新社区
            components = self._get_components()
            if len(components) > len(communities):
                # 合并到新社区
                communities = [list(c) for c in components]
        
        return communities
    
    def _get_components(self):
        visited = set()
        components = []
        
        for node in self.graph:
            if node not in visited:
                component = set()
                queue = [node]
                
                while queue:
                    u = queue.pop()
                    if u in visited:
                        continue
                    visited.add(u)
                    component.add(u)
                    
                    for v in self.graph[u]:
                        if v not in visited:
                            queue.append(v)
                
                components.append(component)
        
        return components

# 测试
gn = GirvanNewman()
gn.add_edge(0, 1)
gn.add_edge(0, 2)
gn.add_edge(0, 3)
gn.add_edge(1, 2)
gn.add_edge(1, 3)
gn.add_edge(2, 3)
gn.add_edge(3, 4)
gn.add_edge(4, 5)
gn.add_edge(4, 6)
gn.add_edge(5, 6)

communities = gn.get_communities(2)
print("社区划分:", communities)
                    </code></pre></div>
                </div>
            </div>

            <h3>Louvain vs Girvan-Newman</h3>
            <div class="algorithm-content">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #3498db; color: white;">
                        <th style="padding: 12px;">特性</th>
                        <th style="padding: 12px;">Louvain</th>
                        <th style="padding: 12px;">Girvan-Newman</th>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px;">时间复杂度</td>
                        <td style="padding: 12px;">O(n log n)</td>
                        <td style="padding: 12px;">O(VE²)</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px;">策略</td>
                        <td style="padding: 12px;">凝聚式</td>
                        <td style="padding: 12px;">分裂式</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px;">大规模网络</td>
                        <td style="padding: 12px;">适合</td>
                        <td style="padding: 12px;">不适合</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px;">层次结构</td>
                        <td style="padding: 12px;">自然产生</td>
                        <td style="padding: 12px;">需额外处理</td>
                    </tr>
                </table>
            </div>

            <h3>社区发现应用场景</h3>
            <div class="algorithm-content">
                <ul>
                    <li><strong>社交网络分析：</strong>发现用户群体、好友圈</li>
                    <li><strong>生物信息学：</strong>蛋白质相互作用网络、功能模块识别</li>
                    <li><strong>推荐系统：</strong>基于社区的协同过滤</li>
                    <li><strong>网络安全：</strong>检测异常社区、僵尸网络</li>
                    <li><strong>市场营销：</strong>细分客户群体</li>
                </ul>
            </div>

            <h3>学习建议</h3>
            <div class="algorithm-content">
                <ul>
                    <li>掌握图的基本表示方法：邻接矩阵和邻接表</li>
                    <li>理解不同算法的适用场景</li>
                    <li>多练习经典问题：最短路径、最小生成树</li>
                    <li>学习BFS和DFS在图中的应用</li>
                    <li>深入理解最大流最小割定理</li>
                    <li>对比Ford-Fulkerson和Dinic算法的效率差异</li>
                    <li>理解残量网络和增广路径的概念</li>
                    <li>理解模块度(Q值)在社区发现中的意义</li>
                    <li>掌握Kruskal的并查集优化和Prim的优先队列优化</li>
                </ul>
            </div>
        </div>
    </section>

    <script src="../js/main.js"></script>
    <script src="../lib/prism/prism.min.js"></script>
    <script src="../lib/prism/prism-python.min.js"></script>
    <script src="../lib/prism/prism-go.min.js"></script>
    <script src="../lib/prism/prism-line-numbers.min.js"></script>
</body>
</html>

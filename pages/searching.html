<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>搜索算法 - 算法学习指南</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <h1 class="logo">AlgoLearn</h1>
            <ul class="nav-links">
                <li><a href="../index.html">首页</a></li>
                <li><a href="../index.html#algorithms">算法分类</a></li>
                <li><a href="../index.html#practice">在线练习</a></li>
            </ul>
        </div>
    </nav>

    <section class="algorithm-detail">
        <div class="container">
            <a href="../index.html#algorithms" class="back-link">← 返回算法分类</a>
            <h2>搜索算法</h2>
            
            <div class="algorithm-content">
                <h3>什么是搜索算法？</h3>
                <p>搜索算法用于在数据集合中查找特定元素或信息。常见的搜索算法包括线性搜索、二分搜索、深度优先搜索、广度优先搜索等。</p>
            </div>

            <div class="complexity">
                <div class="complexity-item">
                    <h4>二分查找</h4>
                    <p>时间: O(log n)</p>
                </div>
                <div class="complexity-item">
                    <h4>DFS/BFS</h4>
                    <p>时间: O(V+E)</p>
                </div>
                <div class="complexity-item">
                    <h4>线性搜索</h4>
                    <p>时间: O(n)</p>
                </div>
            </div>

            <h3>二分查找 (Binary Search)</h3>
            <div class="algorithm-content">
                <p>在有序数组中，通过不断将搜索范围减半来快速定位目标元素。</p>
                <div class="code-block">
                    <pre>
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1; // 未找到
}

// 测试
const sortedArr = [1, 3, 5, 7, 9, 11, 13, 15, 17];
console.log(binarySearch(sortedArr, 7)); // 3
console.log(binarySearch(sortedArr, 4)); // -1
                    </pre>
                </div>
            </div>

            <h3>深度优先搜索 (DFS)</h3>
            <div class="algorithm-content">
                <p>从起点开始，尽可能深地探索图的每个分支，直到无法继续为止，然后回溯。</p>
                <div class="code-block">
                    <pre>
// 图的邻接表表示
const graph = {
    A: ['B', 'C'],
    B: ['D', 'E'],
    C: ['F'],
    D: [],
    E: ['F'],
    F: []
};

function dfs(graph, start) {
    const visited = new Set();
    const result = [];
    
    function dfsHelper(node) {
        visited.add(node);
        result.push(node);
        
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                dfsHelper(neighbor);
            }
        }
    }
    
    dfsHelper(start);
    return result;
}

// 测试
console.log(dfs(graph, 'A')); // ['A', 'B', 'D', 'E', 'F', 'C']
                    </pre>
                </div>
            </div>

            <h3>广度优先搜索 (BFS)</h3>
            <div class="algorithm-content">
                <p>从起点开始，先访问所有相邻节点，然后再依次访问这些节点的相邻节点，逐层向外扩展。</p>
                <div class="code-block">
                    <pre>
// 使用相同的图结构
function bfs(graph, start) {
    const visited = new Set([start]);
    const queue = [start];
    const result = [];
    
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);
        
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return result;
}

// 测试
console.log(bfs(graph, 'A')); // ['A', 'B', 'C', 'D', 'E', 'F']
                    </pre>
                </div>
            </div>

            <h3>DFS vs BFS</h3>
            <div class="algorithm-content">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #3498db; color: white;">
                        <th style="padding: 12px; text-align: left;">特性</th>
                        <th style="padding: 12px; text-align: left;">DFS</th>
                        <th style="padding: 12px; text-align: left;">BFS</th>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px; border: 1px solid #ddd;">数据结构</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">栈</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">队列</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #ddd;">路径选择</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">优先深度</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">优先广度</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 12px; border: 1px solid #ddd;">最短路径</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">不保证</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">保证</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #ddd;">内存使用</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">较少</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">较多</td>
                    </tr>
                </table>
            </div>

            <h3>学习建议</h3>
            <div class="algorithm-content">
                <ul>
                    <li>熟练掌握二分查找，这是最常用的搜索算法</li>
                    <li>理解DFS和BFS的适用场景</li>
                    <li>学习如何处理图和树的搜索问题</li>
                    <li>掌握剪枝技巧优化搜索效率</li>
                </ul>
            </div>
        </div>
    </section>

    <script src="../js/main.js"></script>
</body>
</html>